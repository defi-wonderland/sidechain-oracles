{
  "language": "Solidity",
  "sources": {
    "solidity/for-test/DataReceiverForTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {DataReceiver} from '../contracts/DataReceiver.sol';\nimport {OracleSidechain} from '../contracts/OracleSidechain.sol';\nimport {IDataReceiver, IOracleFactory, IOracleSidechain, IBridgeReceiverAdapter} from '../interfaces/IDataReceiver.sol';\nimport {Create2Address} from '../libraries/Create2Address.sol';\n\ncontract DataReceiverForTest is DataReceiver {\n  constructor(address _governor, IOracleFactory _oracleFactory) DataReceiver(_governor, _oracleFactory) {}\n\n  function internalAddObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external {\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\n  }\n}\n"
    },
    "solidity/contracts/DataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {Governable} from './peripherals/Governable.sol';\nimport {OracleSidechain} from './OracleSidechain.sol';\nimport {IDataReceiver, IOracleFactory, IOracleSidechain, IBridgeReceiverAdapter} from '../interfaces/IDataReceiver.sol';\n\n/// @title The DataReceiver contract\n/// @notice Handles reception of broadcast data and delivers it to correspondant oracle\ncontract DataReceiver is IDataReceiver, Governable {\n  /// @inheritdoc IDataReceiver\n  IOracleFactory public immutable oracleFactory;\n\n  /// @inheritdoc IDataReceiver\n  mapping(bytes32 => IOracleSidechain) public deployedOracles;\n\n  /// @inheritdoc IDataReceiver\n  mapping(IBridgeReceiverAdapter => bool) public whitelistedAdapters;\n\n  /// @inheritdoc IDataReceiver\n  bytes32 public constant ORACLE_INIT_CODE_HASH = 0xe96fe0b2512027e20768d6fa35f894c744d1e6fcff43cb28979f62b5e04adfb1;\n\n  constructor(address _governor, IOracleFactory _oracleFactory) Governable(_governor) {\n    oracleFactory = _oracleFactory;\n  }\n\n  function addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external onlyWhitelistedAdapters {\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\n  }\n\n  function _addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) internal {\n    // Read, store or deploy oracle given poolSalt\n    IOracleSidechain _oracle = deployedOracles[_poolSalt];\n    if (address(_oracle) == address(0)) {\n      _oracle = oracleFactory.getPool(_poolSalt);\n      if (address(_oracle) == address(0)) {\n        _oracle = oracleFactory.deployOracle(_poolSalt, _poolNonce);\n      }\n      deployedOracles[_poolSalt] = _oracle;\n    }\n    // Try to write observations data into oracle\n    if (_oracle.write(_observationsData, _poolNonce)) {\n      emit ObservationsAdded(_poolSalt, _poolNonce, _observationsData, msg.sender);\n    } else {\n      revert ObservationsNotWritable();\n    }\n  }\n\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external onlyGovernor {\n    _whitelistAdapter(_receiverAdapter, _isWhitelisted);\n  }\n\n  /// @inheritdoc IDataReceiver\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external onlyGovernor {\n    uint256 _receiverAdapterLength = _receiverAdapters.length;\n    if (_receiverAdapterLength != _isWhitelisted.length) revert LengthMismatch();\n    unchecked {\n      for (uint256 _i; _i < _receiverAdapterLength; ++_i) {\n        _whitelistAdapter(_receiverAdapters[_i], _isWhitelisted[_i]);\n      }\n    }\n  }\n\n  function _whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) internal {\n    whitelistedAdapters[_receiverAdapter] = _isWhitelisted;\n    emit AdapterWhitelisted(_receiverAdapter, _isWhitelisted);\n  }\n\n  modifier onlyWhitelistedAdapters() {\n    if (!whitelistedAdapters[IBridgeReceiverAdapter(msg.sender)]) revert UnallowedAdapter();\n    _;\n  }\n}\n"
    },
    "solidity/contracts/OracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleSidechain, IOracleFactory} from '../interfaces/IOracleSidechain.sol';\nimport {Oracle} from '@uniswap/v3-core/contracts/libraries/Oracle.sol';\nimport {TickMath} from '@uniswap/v3-core/contracts/libraries/TickMath.sol';\n\n/// @title The SidechainOracle contract\n/// @notice Computes and stores on-chain price data from Mainnet\ncontract OracleSidechain is IOracleSidechain {\n  using Oracle for Oracle.Observation[65535];\n\n  /// @inheritdoc IOracleSidechain\n  IOracleFactory public immutable factory;\n\n  struct Slot0 {\n    // the current price\n    uint160 sqrtPriceX96;\n    // the current tick\n    int24 tick;\n    // the most-recently updated index of the observations array\n    uint16 observationIndex;\n    // the current maximum number of observations that are being stored\n    uint16 observationCardinality;\n    // the next maximum number of observations to store, triggered in observations.write\n    uint16 observationCardinalityNext;\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\n    // represented as an integer denominator (1/x)%\n    uint8 feeProtocol;\n    // whether the pool is locked\n    bool unlocked;\n  }\n  /// @inheritdoc IOracleSidechain\n  Slot0 public slot0;\n\n  /// @inheritdoc IOracleSidechain\n  Oracle.Observation[65535] public observations;\n\n  /// @inheritdoc IOracleSidechain\n  bytes32 public immutable poolSalt;\n\n  uint24 public poolNonce;\n  /// @inheritdoc IOracleSidechain\n  address public token0;\n  /// @inheritdoc IOracleSidechain\n  address public token1;\n  /// @inheritdoc IOracleSidechain\n  uint24 public fee;\n\n  /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\n  function _getBlockTimestamp() internal view virtual returns (uint32) {\n    return uint32(block.timestamp); // truncation is desired\n  }\n\n  constructor() {\n    factory = IOracleFactory(msg.sender);\n    uint16 _cardinality;\n    (poolSalt, poolNonce, _cardinality) = factory.oracleParameters();\n\n    slot0 = Slot0({\n      sqrtPriceX96: 0,\n      tick: 0,\n      observationIndex: _cardinality - 1,\n      observationCardinality: _cardinality,\n      observationCardinalityNext: _cardinality,\n      feeProtocol: 0,\n      unlocked: true\n    });\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function initializePoolInfo(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external {\n    if (!slot0.unlocked) revert AI();\n\n    (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n    if (poolSalt != keccak256(abi.encode(_token0, _token1, _fee))) revert InvalidPool();\n\n    token0 = _token0;\n    token1 = _token1;\n    fee = _fee;\n    slot0.unlocked = false;\n\n    emit PoolInfoInitialized(poolSalt, _token0, _token1, _fee);\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function observe(uint32[] calldata _secondsAgos)\n    external\n    view\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s)\n  {\n    return observations.observe(_getBlockTimestamp(), _secondsAgos, slot0.tick, slot0.observationIndex, 0, slot0.observationCardinality);\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external onlyDataReceiver returns (bool _written) {\n    if (_poolNonce != poolNonce++) return false;\n\n    uint256 _observationsDataLength = _observationsData.length;\n    for (uint256 _i; _i < _observationsDataLength; ) {\n      _write(_observationsData[_i]);\n      unchecked {\n        ++_i;\n      }\n    }\n    slot0.sqrtPriceX96 = TickMath.getSqrtRatioAtTick(slot0.tick);\n\n    // emits UniV3 Swap event topic with minimal data\n    emit Swap(address(0), address(0), 0, 0, slot0.sqrtPriceX96, 0, slot0.tick);\n    return true;\n  }\n\n  function increaseObservationCardinalityNext(uint16 _observationCardinalityNext) external onlyFactory {\n    uint16 _observationCardinalityNextOld = slot0.observationCardinalityNext;\n    if (_observationCardinalityNext <= _observationCardinalityNextOld) return;\n    slot0.observationCardinalityNext = _observationCardinalityNext;\n    emit IncreaseObservationCardinalityNext(_observationCardinalityNextOld, _observationCardinalityNext);\n  }\n\n  function _write(ObservationData memory _observationData) private {\n    (uint16 _indexUpdated, uint16 _cardinalityUpdated) = observations.write(\n      slot0.observationIndex,\n      _observationData.blockTimestamp,\n      slot0.tick,\n      0,\n      slot0.observationCardinality,\n      slot0.observationCardinalityNext\n    );\n    (slot0.observationIndex, slot0.observationCardinality) = (_indexUpdated, _cardinalityUpdated);\n    slot0.tick = _observationData.tick;\n  }\n\n  modifier onlyDataReceiver() {\n    if (msg.sender != address(factory.dataReceiver())) revert OnlyDataReceiver();\n    _;\n  }\n\n  modifier onlyFactory() {\n    if (msg.sender != address(factory)) revert OnlyFactory();\n    _;\n  }\n}\n"
    },
    "solidity/interfaces/IDataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IGovernable} from './peripherals/IGovernable.sol';\nimport {IOracleFactory} from './IOracleFactory.sol';\nimport {IOracleSidechain} from './IOracleSidechain.sol';\nimport {IBridgeReceiverAdapter} from './bridges/IBridgeReceiverAdapter.sol';\n\ninterface IDataReceiver is IGovernable {\n  // STATE VARIABLES\n\n  /// @return _oracleFactory The address of the OracleFactory\n  function oracleFactory() external view returns (IOracleFactory _oracleFactory);\n\n  /// @notice Tracks already deployed oracles\n  /// @param _poolSalt The identifier of the oracle\n  /// @return _deployedOracle The address of the correspondant Oracle\n  function deployedOracles(bytes32 _poolSalt) external view returns (IOracleSidechain _deployedOracle);\n\n  /// @notice Tracks the whitelisting of bridge adapters\n  /// @param _adapter Address of the bridge adapter to consult\n  /// @return _isAllowed Whether a bridge adapter is whitelisted\n  function whitelistedAdapters(IBridgeReceiverAdapter _adapter) external view returns (bool _isAllowed);\n\n  //solhint-disable-next-line func-name-mixedcase\n  function ORACLE_INIT_CODE_HASH() external view returns (bytes32 _oracleInitCodeHash);\n\n  // EVENTS\n\n  /// @notice Emitted when a broadcast observation is succesfully processed\n  /// @param _poolSalt Identifier of the pool to fetch\n  /// @return _poolNonce Nonce of the observation broadcast\n  /// @return _observationsData Array of tuples containing the dataset\n  /// @return _receiverAdapter Handler of the broadcast\n  event ObservationsAdded(\n    bytes32 indexed _poolSalt,\n    uint24 _poolNonce,\n    IOracleSidechain.ObservationData[] _observationsData,\n    address _receiverAdapter\n  );\n\n  /// @notice Emitted when a new adapter whitelisting rule is set\n  /// @param _adapter Address of the adapter\n  /// @param _isAllowed New whitelisting status\n  event AdapterWhitelisted(IBridgeReceiverAdapter _adapter, bool _isAllowed);\n\n  // ERRORS\n\n  /// @notice Thrown when the broadcast nonce is incorrect\n  error ObservationsNotWritable();\n\n  /// @notice Thrown when a not-whitelisted adapter triggers an update\n  error UnallowedAdapter();\n\n  /// @notice Thrown when mismatching lists length\n  error LengthMismatch();\n\n  // FUNCTIONS\n\n  /// @notice Allows whitelisted bridge adapters to push a broadcast\n  /// @param _observationsData Array of tuples containing the dataset\n  /// @param _poolSalt Identifier of the pool to fetch\n  /// @param _poolNonce Nonce of the observation broadcast\n  function addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external;\n\n  /// @notice Allows governance to set an adapter whitelisted state\n  /// @param _receiverAdapter Address of the adapter\n  /// @param _isWhitelisted New whitelisting status\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external;\n\n  /// @notice Allows governance to batch set adapters whitelisted state\n  /// @param _receiverAdapters Array of addresses of the adapter\n  /// @param _isWhitelisted Array of whitelisting status for each address\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external;\n}\n"
    },
    "solidity/libraries/Create2Address.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.8 <0.9.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary Create2Address {\n  /// @notice Deterministically computes the pool address given the factory, salt and initCodeHash\n  /// @param _factory The Uniswap V3 factory contract address\n  /// @param _salt The PoolKey encoded bytes\n  /// @param _initCodeHash The Init Code Hash of the target\n  /// @return _pool The contract address of the target pool/oracle\n  function computeAddress(\n    address _factory,\n    bytes32 _salt,\n    bytes32 _initCodeHash\n  ) internal pure returns (address _pool) {\n    _pool = address(uint160(uint256(keccak256(abi.encodePacked(hex'ff', _factory, _salt, _initCodeHash)))));\n  }\n}\n"
    },
    "solidity/contracts/peripherals/Governable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IGovernable} from '../../interfaces/peripherals/IGovernable.sol';\n\nabstract contract Governable is IGovernable {\n  /// @inheritdoc IGovernable\n  address public governor;\n\n  /// @inheritdoc IGovernable\n  address public pendingGovernor;\n\n  constructor(address _governor) {\n    if (_governor == address(0)) revert ZeroAddress();\n    governor = _governor;\n  }\n\n  /// @inheritdoc IGovernable\n  function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\n    _setPendingGovernor(_pendingGovernor);\n  }\n\n  /// @inheritdoc IGovernable\n  function acceptPendingGovernor() external onlyPendingGovernor {\n    _acceptPendingGovernor();\n  }\n\n  function _setPendingGovernor(address _pendingGovernor) internal {\n    if (_pendingGovernor == address(0)) revert ZeroAddress();\n    pendingGovernor = _pendingGovernor;\n    emit PendingGovernorSet(governor, pendingGovernor);\n  }\n\n  function _acceptPendingGovernor() internal {\n    governor = pendingGovernor;\n    pendingGovernor = address(0);\n    emit PendingGovernorAccepted(governor);\n  }\n\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert OnlyGovernor();\n    _;\n  }\n\n  modifier onlyPendingGovernor() {\n    if (msg.sender != pendingGovernor) revert OnlyPendingGovernor();\n    _;\n  }\n}\n"
    },
    "solidity/interfaces/peripherals/IGovernable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\ninterface IGovernable {\n  // STATE VARIABLES\n\n  /// @return _governor Address of the current governor\n  function governor() external view returns (address _governor);\n\n  /// @return _pendingGovernor Address of the current pending governor\n  function pendingGovernor() external view returns (address _pendingGovernor);\n\n  // EVENTS\n\n  /// @notice Emitted when a new pending governor is set\n  /// @param _governor Address of the current governor\n  /// @param _pendingGovernor Address of the proposed next governor\n  event PendingGovernorSet(address _governor, address _pendingGovernor);\n\n  /// @notice Emitted when a new governor is set\n  /// @param _newGovernor Address of the new governor\n  event PendingGovernorAccepted(address _newGovernor);\n\n  // ERRORS\n\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if a non-governor user tries to call a OnlyGovernor function\n  error OnlyGovernor();\n\n  /// @notice Throws if a non-pending-governor user tries to call a OnlyPendingGovernor function\n  error OnlyPendingGovernor();\n\n  // FUNCTIONS\n\n  /// @notice Allows a governor to propose a new governor\n  /// @param _pendingGovernor Address of the proposed new governor\n  function setPendingGovernor(address _pendingGovernor) external;\n\n  /// @notice Allows a proposed governor to accept the governance\n  function acceptPendingGovernor() external;\n}\n"
    },
    "solidity/interfaces/IOracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleFactory} from './IOracleFactory.sol';\n\ninterface IOracleSidechain {\n  // STRUCTS\n\n  struct ObservationData {\n    uint32 blockTimestamp;\n    int24 tick;\n  }\n\n  // STATE VARIABLES\n\n  // TODO: complete natspec\n\n  /// @return _oracleFactory The address of the OracleFactory\n  function factory() external view returns (IOracleFactory _oracleFactory);\n\n  /// @return _token0 The mainnet address of the Token0 of the oracle\n  function token0() external view returns (address _token0);\n\n  /// @return _token1 The mainnet address of the Token1 of the oracle\n  function token1() external view returns (address _token1);\n\n  /// @return _fee The fee identifier of the pool\n  function fee() external view returns (uint24 _fee);\n\n  /// @return _poolSalt The identifier of both the pool and the oracle\n  function poolSalt() external view returns (bytes32 _poolSalt);\n\n  /// @return _poolNonce Last recorded nonce of the pool history\n  function poolNonce() external view returns (uint24 _poolNonce);\n\n  /// @notice Replicates the UniV3Pool slot0 behaviour (semi-compatible)\n  /// @return _sqrtPriceX96 Used to maintain compatibility with Uniswap V3\n  /// @return _tick Used to maintain compatibility with Uniswap V3\n  /// @return _observationIndex The index of the last oracle observation that was written,\n  /// @return _observationCardinality The current maximum number of observations stored in the pool,\n  /// @return _observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// @return _feeProtocol Used to maintain compatibility with Uniswap V3\n  /// @return _unlocked Used to track if a pool information was already verified\n  function slot0()\n    external\n    view\n    returns (\n      uint160 _sqrtPriceX96,\n      int24 _tick,\n      uint16 _observationIndex,\n      uint16 _observationCardinality,\n      uint16 _observationCardinalityNext,\n      uint8 _feeProtocol,\n      bool _unlocked\n    );\n\n  /// @notice Returns data about a specific observation index\n  /// @param _index The element of the observations array to fetch\n  /// @return _blockTimestamp The timestamp of the observation,\n  /// @return _tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// @return _secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// @return _initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 _index)\n    external\n    view\n    returns (\n      uint32 _blockTimestamp,\n      int56 _tickCumulative,\n      uint160 _secondsPerLiquidityCumulativeX128,\n      bool _initialized\n    );\n\n  // EVENTS\n\n  /// @notice Emitted when the pool information is verified\n  /// @param _poolSalt Identifier of the pool and the oracle\n  /// @param _token0 The contract address of either token0 or token1\n  /// @param _token1 The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  event PoolInfoInitialized(bytes32 indexed _poolSalt, address _token0, address _token1, uint24 _fee);\n\n  /// @notice Emitted by the oracle to hint indexers that the pool state has changed\n  /// @dev Imported from IUniswapV3PoolEvents (semi-compatible)\n  /// @param _sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param _tick The log base 1.0001 of price of the pool after the swap\n  event Swap(address indexed, address indexed, int256, int256, uint160 _sqrtPriceX96, uint128, int24 _tick);\n\n  /// @notice Emitted by the oracle for increases to the number of observations that can be stored\n  /// @dev Imported from IUniswapV3PoolEvents (fully-compatible)\n  /// @param _observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param _observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(uint16 _observationCardinalityNextOld, uint16 _observationCardinalityNextNew);\n\n  // ERRORS\n\n  error AI();\n  error InvalidPool();\n  error OnlyDataReceiver();\n  error OnlyFactory();\n\n  // FUNCTIONS\n\n  /// @notice Permisionless method to verify token0, token1 and fee\n  /// @dev Before verified, token0 and token1 views will return address(0)\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  function initializePoolInfo(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external;\n\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev Imported from UniV3Pool (semi compatible, optimistically extrapolates)\n  /// @param _secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return _tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return _secondsCumulativeX128s Cumulative seconds as of each `secondsAgos` from the current block timestamp\n  function observe(uint32[] calldata _secondsAgos)\n    external\n    view\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsCumulativeX128s);\n\n  /// @notice Permisioned method to push a dataset to update\n  /// @param _observationsData Array of tuples containing the dataset\n  /// @param _poolNonce Nonce of the observation broadcast\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external returns (bool _written);\n\n  /// @notice Permisioned method to increase the cardinalityNext value\n  /// @param _observationCardinalityNext The new next length of the observations array\n  function increaseObservationCardinalityNext(uint16 _observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/Oracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    error I();\n    error OLD();\n\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity\n    ) private pure returns (Observation memory) {\n        unchecked {\n            uint32 delta = blockTimestamp - last.blockTimestamp;\n            return\n                Observation({\n                    blockTimestamp: blockTimestamp,\n                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\n                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                    initialized: true\n                });\n        }\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[65535] storage self, uint32 time)\n        internal\n        returns (uint16 cardinality, uint16 cardinalityNext)\n    {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        unchecked {\n            Observation memory last = self[index];\n\n            // early return if we've already written an observation this block\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n            // if the conditions are right, we can bump the cardinality\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            indexUpdated = (index + 1) % cardinalityUpdated;\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n        }\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(\n        Observation[65535] storage self,\n        uint16 current,\n        uint16 next\n    ) internal returns (uint16) {\n        unchecked {\n            if (current <= 0) revert I();\n            // no-op if the passed next value isn't greater than the current next value\n            if (next <= current) return current;\n            // store in each slot to prevent fresh SSTOREs in swaps\n            // this data will not be used because the initialized boolean is still false\n            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\n            return next;\n        }\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return Whether `a` is chronologically <= `b`\n    function lte(\n        uint32 time,\n        uint32 a,\n        uint32 b\n    ) private pure returns (bool) {\n        unchecked {\n            // if there hasn't been overflow, no need to adjust\n            if (a <= time && b <= time) return a <= b;\n\n            uint256 aAdjusted = a > time ? a : a + 2**32;\n            uint256 bAdjusted = b > time ? b : b + 2**32;\n\n            return aAdjusted <= bAdjusted;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        uint16 index,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            uint256 l = (index + 1) % cardinality; // oldest observation\n            uint256 r = l + cardinality - 1; // newest observation\n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = self[i % cardinality];\n\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\n                if (!beforeOrAt.initialized) {\n                    l = i + 1;\n                    continue;\n                }\n\n                atOrAfter = self[(i + 1) % cardinality];\n\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n                // check if we've found the answer!\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n                if (!targetAtOrAfter) r = i - 1;\n                else l = i + 1;\n            }\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The total pool liquidity at the time of the call\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            // optimistically set before to the newest observation\n            beforeOrAt = self[index];\n\n            // if the target is chronologically at or after the newest observation, we can early return\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                if (beforeOrAt.blockTimestamp == target) {\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                    return (beforeOrAt, atOrAfter);\n                } else {\n                    // otherwise, we need to transform\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n                }\n            }\n\n            // now, set before to the oldest observation\n            beforeOrAt = self[(index + 1) % cardinality];\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n            // ensure that the target is chronologically at or after the oldest observation\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\n\n            // if we've reached this point, we have to binary search\n            return binarySearch(self, time, target, index, cardinality);\n        }\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n        unchecked {\n            if (secondsAgo == 0) {\n                Observation memory last = self[index];\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n            }\n\n            uint32 target = time - secondsAgo;\n\n            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\n                self,\n                time,\n                target,\n                tick,\n                index,\n                liquidity,\n                cardinality\n            );\n\n            if (target == beforeOrAt.blockTimestamp) {\n                // we're at the left boundary\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n            } else if (target == atOrAfter.blockTimestamp) {\n                // we're at the right boundary\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n            } else {\n                // we're in the middle\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n                return (\n                    beforeOrAt.tickCumulative +\n                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\n                        int56(uint56(targetDelta)),\n                    beforeOrAt.secondsPerLiquidityCumulativeX128 +\n                        uint160(\n                            (uint256(\n                                atOrAfter.secondsPerLiquidityCumulativeX128 -\n                                    beforeOrAt.secondsPerLiquidityCumulativeX128\n                            ) * targetDelta) / observationTimeDelta\n                        )\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n        unchecked {\n            if (cardinality <= 0) revert I();\n\n            tickCumulatives = new int56[](secondsAgos.length);\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\n                    self,\n                    time,\n                    secondsAgos[i],\n                    tick,\n                    index,\n                    liquidity,\n                    cardinality\n                );\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "solidity/interfaces/IOracleFactory.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IGovernable} from './peripherals/IGovernable.sol';\nimport {IOracleSidechain} from './IOracleSidechain.sol';\nimport {IDataReceiver} from './IDataReceiver.sol';\n\ninterface IOracleFactory is IGovernable {\n  // STRUCTS\n\n  struct OracleParameters {\n    bytes32 poolSalt; // Identifier of the pool and oracle\n    uint24 poolNonce; // Initial nonce of the deployed pool\n    uint16 cardinality; // Initial cardinality of the deployed pool\n  }\n\n  // STATE VARIABLES\n\n  /// @return _dataReceiver The address of the DataReceiver for the oracles to consult\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\n\n  /// @return _poolSalt The id of both the oracle and the pool\n  /// @return _poolNonce The initial nonce of the pool data\n  /// @return _cardinality The size of the observations memory storage\n  function oracleParameters()\n    external\n    view\n    returns (\n      bytes32 _poolSalt,\n      uint24 _poolNonce,\n      uint16 _cardinality\n    );\n\n  /// @return _initialCardinality The initial size of the observations memory storage for newly deployed pools\n  function initialCardinality() external view returns (uint16 _initialCardinality);\n\n  // EVENTS\n\n  /// @notice Emitted when a new oracle is deployed\n  /// @param _poolSalt The id of both the oracle and the pool\n  /// @param _oracle The address of the deployed oracle\n  /// @param _initialNonce The initial nonce of the pool data\n  event OracleDeployed(bytes32 indexed _poolSalt, address indexed _oracle, uint24 _initialNonce);\n\n  /// @notice Emitted when a new DataReceiver is set\n  /// @param _dataReceiver The address of the new DataReceiver\n  event DataReceiverSet(IDataReceiver _dataReceiver);\n\n  /// @notice Emitted when a new initial oracle cardinality is set\n  /// @param _initialCardinality The initial length of the observationCardinality array\n  event InitialCardinalitySet(uint16 _initialCardinality);\n\n  // ERRORS\n\n  /// @notice Thrown when a contract other than the DataReceiver tries to deploy an oracle\n  error OnlyDataReceiver();\n\n  // FUNCTIONS\n\n  /// @notice Deploys a new oracle given an inputted salt\n  /// @dev Requires that the salt has not been deployed before\n  /// @param _poolSalt Pool salt that deterministically binds an oracle with a pool\n  /// @return _oracle The address of the newly deployed oracle\n  function deployOracle(bytes32 _poolSalt, uint24 _poolNonce) external returns (IOracleSidechain _oracle);\n\n  /// @notice Allows governor to set a new allowed dataReceiver\n  /// @dev Will disallow the previous dataReceiver\n  /// @param _dataReceiver The address of the new allowed dataReceiver\n  function setDataReceiver(IDataReceiver _dataReceiver) external;\n\n  /// @notice Allows governor to set a new initial cardinality for new oracles\n  /// @param _initialCardinality The initial size of the observations memory storage for newly deployed pools\n  function setInitialCardinality(uint16 _initialCardinality) external;\n\n  /// @notice Overrides UniV3Factory getPool mapping\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  /// @return _oracle The oracle address\n  function getPool(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external view returns (IOracleSidechain _oracle);\n\n  /// @notice Tracks the addresses of the oracle by poolSalt\n  /// @param _poolSalt Identifier of both the pool and the oracle\n  /// @return _oracle The address (if deployed) of the correspondant oracle\n  function getPool(bytes32 _poolSalt) external view returns (IOracleSidechain _oracle);\n\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  /// @return _poolSalt Pool salt for inquired parameters\n  function getPoolSalt(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external view returns (bytes32 _poolSalt);\n}\n"
    },
    "solidity/interfaces/bridges/IBridgeReceiverAdapter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IDataReceiver} from '../IDataReceiver.sol';\nimport {IOracleSidechain} from '../IOracleSidechain.sol';\n\ninterface IBridgeReceiverAdapter {\n  // FUNCTIONS\n\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\n\n  /* NOTE: callback methods should be here declared */\n\n  // ERRORS\n\n  error UnauthorizedCaller();\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}