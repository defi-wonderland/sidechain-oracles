{
  "language": "Solidity",
  "sources": {
    "solidity/interfaces/IDataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleSidechain} from '../interfaces/IOracleSidechain.sol';\n\n/// @title The DataReceiver interface\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Contains state variables, events, custom errors and functions used in DataReceiver\ninterface IDataReceiver {\n  // STATE VARIABLES\n\n  function oracleSidechain() external view returns (IOracleSidechain _oracleSidechain);\n\n  // EVENTS\n\n  event ObservationAdded(address user, uint32 blockTimestamp, int24 tick);\n\n  // CUSTOM ERRORS\n\n  error ObservationNotWritable(uint32 blockTimestamp);\n\n  // FUNCTIONS\n\n  function addObservation(uint32 _blockTimestamp, int24 _tick) external;\n}\n"
    },
    "solidity/interfaces/IOracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\n/// @title The OracleSidechain interface\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Contains state variables, events, custom errors and functions used in OracleSidechain\ninterface IOracleSidechain {\n  // STATE VARIABLES\n\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return observationIndex The index of the last oracle observation that was written,\n  /// @return observationCardinality The current maximum number of observations stored in the pool,\n  /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  function slot0()\n    external\n    view\n    returns (\n      uint16 observationIndex,\n      uint16 observationCardinality,\n      uint16 observationCardinalityNext\n    );\n\n  function lastTick() external view returns (int24 lastTick);\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// @return initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 index)\n    external\n    view\n    returns (\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      uint160 secondsPerLiquidityCumulativeX128,\n      bool initialized\n    );\n\n  // EVENTS\n\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(uint16 observationCardinalityNextOld, uint16 observationCardinalityNextNew);\n\n  event ObservationWritten(address user, uint32 blockTimestamp, int24 tick);\n\n  // CUSTOM ERRORS\n\n  error AI();\n\n  // FUNCTIONS\n\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata secondsAgos)\n    external\n    view\n    returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  function write(uint32 blockTimestamp, int24 tick) external returns (bool written);\n\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "solidity/contracts/OracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {Oracle} from '@uniswap/v3-core/contracts/libraries/Oracle.sol';\nimport {TickMath} from '@uniswap/v3-core/contracts/libraries/TickMath.sol';\nimport {IOracleSidechain} from '../interfaces/IOracleSidechain.sol';\n\n/// @title A sidechain oracle contract\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Computes on-chain price data from Mainnet\n/// @dev Bridges Uniswap V3 pool observations\ncontract OracleSidechain is IOracleSidechain {\n  using Oracle for Oracle.Observation[65535];\n\n  struct Slot0 {\n    // the most-recently updated index of the observations array\n    uint16 observationIndex;\n    // the current maximum number of observations that are being stored\n    uint16 observationCardinality;\n    // the next maximum number of observations to store, triggered in observations.write\n    uint16 observationCardinalityNext;\n  }\n  /// @inheritdoc IOracleSidechain\n  Slot0 public override slot0;\n\n  int24 public lastTick;\n\n  /// @inheritdoc IOracleSidechain\n  Oracle.Observation[65535] public override observations;\n\n  /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\n  function _blockTimestamp() internal view virtual returns (uint32) {\n    return uint32(block.timestamp); // truncation is desired\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function observe(uint32[] calldata secondsAgos)\n    external\n    view\n    override\n    returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)\n  {\n    return observations.observe(_blockTimestamp(), secondsAgos, lastTick, slot0.observationIndex, 0, slot0.observationCardinality);\n  }\n\n  function write(uint32 blockTimestamp, int24 tick) external returns (bool written) {\n    Slot0 memory _slot0 = slot0;\n    Oracle.Observation memory lastObservation = observations[_slot0.observationIndex];\n    if (lastObservation.blockTimestamp != blockTimestamp) {\n      (uint16 indexUpdated, uint16 cardinalityUpdated) = observations.write(\n        _slot0.observationIndex,\n        blockTimestamp,\n        tick,\n        0,\n        _slot0.observationCardinality,\n        _slot0.observationCardinalityNext\n      );\n      (slot0.observationIndex, slot0.observationCardinality) = (indexUpdated, cardinalityUpdated);\n      lastTick = tick;\n      written = true;\n      emit ObservationWritten(msg.sender, blockTimestamp, tick);\n    }\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external override {\n    uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event\n    uint16 observationCardinalityNextNew = observations.grow(observationCardinalityNextOld, observationCardinalityNext);\n    slot0.observationCardinalityNext = observationCardinalityNextNew;\n    if (observationCardinalityNextOld != observationCardinalityNextNew)\n      emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function initialize(uint160 sqrtPriceX96) external override {\n    if (slot0.observationCardinality != 0) revert AI();\n\n    lastTick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n    (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());\n\n    slot0 = Slot0({observationIndex: 0, observationCardinality: cardinality, observationCardinalityNext: cardinalityNext});\n\n    emit Initialize(sqrtPriceX96, lastTick);\n  }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/Oracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    error I();\n    error OLD();\n\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity\n    ) private pure returns (Observation memory) {\n        unchecked {\n            uint32 delta = blockTimestamp - last.blockTimestamp;\n\n            return\n                Observation({\n                    blockTimestamp: blockTimestamp,\n                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\n                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                    initialized: true\n                });\n        }\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[65535] storage self, uint32 time)\n        internal\n        returns (uint16 cardinality, uint16 cardinalityNext)\n    {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        unchecked {\n            Observation memory last = self[index];\n\n            // early return if we've already written an observation this block\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n            // if the conditions are right, we can bump the cardinality\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            indexUpdated = (index + 1) % cardinalityUpdated;\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n        }\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(\n        Observation[65535] storage self,\n        uint16 current,\n        uint16 next\n    ) internal returns (uint16) {\n        unchecked {\n            if (current <= 0) revert I();\n            // no-op if the passed next value isn't greater than the current next value\n            if (next <= current) return current;\n            // store in each slot to prevent fresh SSTOREs in swaps\n            // this data will not be used because the initialized boolean is still false\n            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\n            return next;\n        }\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return Whether `a` is chronologically <= `b`\n    function lte(\n        uint32 time,\n        uint32 a,\n        uint32 b\n    ) private pure returns (bool) {\n        unchecked {\n            // if there hasn't been overflow, no need to adjust\n            if (a <= time && b <= time) return a <= b;\n\n            uint256 aAdjusted = a > time ? a : a + 2**32;\n            uint256 bAdjusted = b > time ? b : b + 2**32;\n\n            return aAdjusted <= bAdjusted;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        uint16 index,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            uint256 l = (index + 1) % cardinality; // oldest observation\n            uint256 r = l + cardinality - 1; // newest observation\n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = self[i % cardinality];\n\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\n                if (!beforeOrAt.initialized) {\n                    l = i + 1;\n                    continue;\n                }\n\n                atOrAfter = self[(i + 1) % cardinality];\n\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n                // check if we've found the answer!\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n                if (!targetAtOrAfter) r = i - 1;\n                else l = i + 1;\n            }\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The total pool liquidity at the time of the call\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            // optimistically set before to the newest observation\n            beforeOrAt = self[index];\n\n            // if the target is chronologically at or after the newest observation, we can early return\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                if (beforeOrAt.blockTimestamp == target) {\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                    return (beforeOrAt, atOrAfter);\n                } else {\n                    // otherwise, we need to transform\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n                }\n            }\n\n            // now, set before to the oldest observation\n            beforeOrAt = self[(index + 1) % cardinality];\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n            // ensure that the target is chronologically at or after the oldest observation\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\n\n            // if we've reached this point, we have to binary search\n            return binarySearch(self, time, target, index, cardinality);\n        }\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n        unchecked {\n            if (secondsAgo == 0) {\n                Observation memory last = self[index];\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n            }\n\n            uint32 target = time - secondsAgo;\n\n            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\n                self,\n                time,\n                target,\n                tick,\n                index,\n                liquidity,\n                cardinality\n            );\n\n            if (target == beforeOrAt.blockTimestamp) {\n                // we're at the left boundary\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n            } else if (target == atOrAfter.blockTimestamp) {\n                // we're at the right boundary\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n            } else {\n                // we're in the middle\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n                return (\n                    beforeOrAt.tickCumulative +\n                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\n                        int56(uint56(targetDelta)),\n                    beforeOrAt.secondsPerLiquidityCumulativeX128 +\n                        uint160(\n                            (uint256(\n                                atOrAfter.secondsPerLiquidityCumulativeX128 -\n                                    beforeOrAt.secondsPerLiquidityCumulativeX128\n                            ) * targetDelta) / observationTimeDelta\n                        )\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n        unchecked {\n            if (cardinality <= 0) revert I();\n\n            tickCumulatives = new int56[](secondsAgos.length);\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\n                    self,\n                    time,\n                    secondsAgos[i],\n                    tick,\n                    index,\n                    liquidity,\n                    cardinality\n                );\n            }\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    error T();\n    error R();\n\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n            uint256 ratio = absTick & 0x1 != 0\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\n                : 0x100000000000000000000000000000000;\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            if (tick > 0) ratio = type(uint256).max / ratio;\n\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        unchecked {\n            // second inequality must be < because the price can never reach the price at the max tick\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = ratio;\n            uint256 msb = 0;\n\n            assembly {\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(5, gt(r, 0xFFFFFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(4, gt(r, 0xFFFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(3, gt(r, 0xFF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(2, gt(r, 0xF))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := shl(1, gt(r, 0x3))\n                msb := or(msb, f)\n                r := shr(f, r)\n            }\n            assembly {\n                let f := gt(r, 0x1)\n                msb := or(msb, f)\n            }\n\n            if (msb >= 128) r = ratio >> (msb - 127);\n            else r = ratio << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n        }\n    }\n}\n"
    },
    "solidity/contracts/DataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IDataReceiver, IOracleSidechain} from '../interfaces/IDataReceiver.sol';\n\ncontract DataReceiver is IDataReceiver {\n  IOracleSidechain public immutable oracleSidechain;\n\n  constructor(IOracleSidechain _oracleSidechain) {\n    oracleSidechain = _oracleSidechain;\n  }\n\n  function addObservation(uint32 _blockTimestamp, int24 _tick) external {\n    if (oracleSidechain.write(_blockTimestamp, _tick)) {\n      emit ObservationAdded(msg.sender, _blockTimestamp, _tick);\n    } else {\n      revert ObservationNotWritable(_blockTimestamp);\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, _allowances[owner][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = _allowances[owner][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Spend `amount` form the allowance of `owner` toward `spender`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/ContextUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20BurnableUpgradeable is Initializable, ContextUpgradeable, ERC20Upgradeable {\n    function __ERC20Burnable_init() internal onlyInitializing {\n    }\n\n    function __ERC20Burnable_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Destroys `amount` tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 amount) public virtual {\n        _burn(_msgSender(), amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n     * allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `amount`.\n     */\n    function burnFrom(address account, uint256 amount) public virtual {\n        _spendAllowance(account, _msgSender(), amount);\n        _burn(account, amount);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/XAppConnectionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// ============ Internal Imports ============\nimport {Home} from \"./Home.sol\";\nimport {Replica} from \"./Replica.sol\";\nimport {TypeCasts} from \"../libs/TypeCasts.sol\";\n// ============ External Imports ============\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title XAppConnectionManager\n * @author Illusory Systems Inc.\n * @notice Manages a registry of local Replica contracts\n * for remote Home domains. Accepts Watcher signatures\n * to un-enroll Replicas attached to fraudulent remote Homes\n */\ncontract XAppConnectionManager is Ownable {\n  // ============ Public Storage ============\n\n  // Home contract\n  Home public home;\n  // local Replica address => remote Home domain\n  mapping(address => uint32) public replicaToDomain;\n  // remote Home domain => local Replica address\n  mapping(uint32 => address) public domainToReplica;\n  // watcher address => replica remote domain => has/doesn't have permission\n  mapping(address => mapping(uint32 => bool)) private watcherPermissions;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new Replica is enrolled / added\n   * @param domain the remote domain of the Home contract for the Replica\n   * @param replica the address of the Replica\n   */\n  event ReplicaEnrolled(uint32 indexed domain, address replica);\n\n  /**\n   * @notice Emitted when a new Replica is un-enrolled / removed\n   * @param domain the remote domain of the Home contract for the Replica\n   * @param replica the address of the Replica\n   */\n  event ReplicaUnenrolled(uint32 indexed domain, address replica);\n\n  /**\n   * @notice Emitted when Watcher permissions are changed\n   * @param domain the remote domain of the Home contract for the Replica\n   * @param watcher the address of the Watcher\n   * @param access TRUE if the Watcher was given permissions, FALSE if permissions were removed\n   */\n  event WatcherPermissionSet(uint32 indexed domain, address watcher, bool access);\n\n  // ============ Modifiers ============\n\n  modifier onlyReplica() {\n    require(isReplica(msg.sender), \"!replica\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  // solhint-disable-next-line no-empty-blocks\n  constructor() Ownable() {}\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Un-Enroll a replica contract\n   * in the case that fraud was detected on the Home\n   * @dev in the future, if fraud occurs on the Home contract,\n   * the Watcher will submit their signature directly to the Home\n   * and it can be relayed to all remote chains to un-enroll the Replicas\n   * @param _domain the remote domain of the Home contract for the Replica\n   * @param _updater the address of the Updater for the Home contract (also stored on Replica)\n   * @param _signature signature of watcher on (domain, replica address, updater address)\n   */\n  function unenrollReplica(\n    uint32 _domain,\n    bytes32 _updater,\n    bytes memory _signature\n  ) external {\n    // ensure that the replica is currently set\n    address _replica = domainToReplica[_domain];\n    require(_replica != address(0), \"!replica exists\");\n    // ensure that the signature is on the proper updater\n    require(Replica(_replica).updater() == TypeCasts.bytes32ToAddress(_updater), \"!current updater\");\n    // get the watcher address from the signature\n    // and ensure that the watcher has permission to un-enroll this replica\n    address _watcher = _recoverWatcherFromSig(_domain, TypeCasts.addressToBytes32(_replica), _updater, _signature);\n    require(watcherPermissions[_watcher][_domain], \"!valid watcher\");\n    // remove the replica from mappings\n    _unenrollReplica(_replica);\n  }\n\n  /**\n   * @notice Set the address of the local Home contract\n   * @param _home the address of the local Home contract\n   */\n  function setHome(address _home) external onlyOwner {\n    home = Home(_home);\n  }\n\n  /**\n   * @notice Allow Owner to enroll Replica contract\n   * @param _replica the address of the Replica\n   * @param _domain the remote domain of the Home contract for the Replica\n   */\n  function ownerEnrollReplica(address _replica, uint32 _domain) external onlyOwner {\n    // un-enroll any existing replica\n    _unenrollReplica(_replica);\n    // add replica and domain to two-way mapping\n    replicaToDomain[_replica] = _domain;\n    domainToReplica[_domain] = _replica;\n    emit ReplicaEnrolled(_domain, _replica);\n  }\n\n  /**\n   * @notice Allow Owner to un-enroll Replica contract\n   * @param _replica the address of the Replica\n   */\n  function ownerUnenrollReplica(address _replica) external onlyOwner {\n    _unenrollReplica(_replica);\n  }\n\n  /**\n   * @notice Allow Owner to set Watcher permissions for a Replica\n   * @param _watcher the address of the Watcher\n   * @param _domain the remote domain of the Home contract for the Replica\n   * @param _access TRUE to give the Watcher permissions, FALSE to remove permissions\n   */\n  function setWatcherPermission(\n    address _watcher,\n    uint32 _domain,\n    bool _access\n  ) external onlyOwner {\n    watcherPermissions[_watcher][_domain] = _access;\n    emit WatcherPermissionSet(_domain, _watcher, _access);\n  }\n\n  /**\n   * @notice Query local domain from Home\n   * @return local domain\n   */\n  function localDomain() external view returns (uint32) {\n    return home.localDomain();\n  }\n\n  /**\n   * @notice Get access permissions for the watcher on the domain\n   * @param _watcher the address of the watcher\n   * @param _domain the domain to check for watcher permissions\n   * @return TRUE iff _watcher has permission to un-enroll replicas on _domain\n   */\n  function watcherPermission(address _watcher, uint32 _domain) external view returns (bool) {\n    return watcherPermissions[_watcher][_domain];\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Check whether _replica is enrolled\n   * @param _replica the replica to check for enrollment\n   * @return TRUE iff _replica is enrolled\n   */\n  function isReplica(address _replica) public view returns (bool) {\n    return replicaToDomain[_replica] != 0;\n  }\n\n  // ============ Internal Functions ============\n\n  /**\n   * @notice Remove the replica from the two-way mappings\n   * @param _replica replica to un-enroll\n   */\n  function _unenrollReplica(address _replica) internal {\n    uint32 _currentDomain = replicaToDomain[_replica];\n    domainToReplica[_currentDomain] = address(0);\n    replicaToDomain[_replica] = 0;\n    emit ReplicaUnenrolled(_currentDomain, _replica);\n  }\n\n  /**\n   * @notice Get the Watcher address from the provided signature\n   * @return address of watcher that signed\n   */\n  function _recoverWatcherFromSig(\n    uint32 _domain,\n    bytes32 _replica,\n    bytes32 _updater,\n    bytes memory _signature\n  ) internal view returns (address) {\n    bytes32 _homeDomainHash = Replica(TypeCasts.bytes32ToAddress(_replica)).homeDomainHash();\n    bytes32 _digest = keccak256(abi.encodePacked(_homeDomainHash, _domain, _updater));\n    _digest = ECDSA.toEthSignedMessageHash(_digest);\n    return ECDSA.recover(_digest, _signature);\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/Home.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// ============ Internal Imports ============\nimport {Version0} from \"./Version0.sol\";\nimport {NomadBase} from \"./NomadBase.sol\";\nimport {QueueLib} from \"../libs/Queue.sol\";\nimport {MerkleLib} from \"../libs/Merkle.sol\";\nimport {Message} from \"../libs/Message.sol\";\nimport {MerkleTreeManager} from \"./Merkle.sol\";\nimport {QueueManager} from \"./Queue.sol\";\nimport {IUpdaterManager} from \"../interfaces/IUpdaterManager.sol\";\n// ============ External Imports ============\nimport {Address} from \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title Home\n * @author Illusory Systems Inc.\n * @notice Accepts messages to be dispatched to remote chains,\n * constructs a Merkle tree of the messages,\n * and accepts signatures from a bonded Updater\n * which notarize the Merkle tree roots.\n * Accepts submissions of fraudulent signatures\n * by the Updater and slashes the Updater in this case.\n */\ncontract Home is Version0, QueueManager, MerkleTreeManager, NomadBase {\n  // ============ Libraries ============\n\n  using QueueLib for QueueLib.Queue;\n  using MerkleLib for MerkleLib.Tree;\n\n  // ============ Constants ============\n\n  // Maximum bytes per message = 2 KiB\n  // (somewhat arbitrarily set to begin)\n  uint256 public constant MAX_MESSAGE_BODY_BYTES = 2 * 2**10;\n\n  // ============ Public Storage Variables ============\n\n  // domain => next available nonce for the domain\n  mapping(uint32 => uint32) public nonces;\n  // contract responsible for Updater bonding, slashing and rotation\n  IUpdaterManager public updaterManager;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[48] private __GAP;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when a new message is dispatched via Nomad\n   * @param leafIndex Index of message's leaf in merkle tree\n   * @param destinationAndNonce Destination and destination-specific\n   * nonce combined in single field ((destination << 32) & nonce)\n   * @param messageHash Hash of message; the leaf inserted to the Merkle tree for the message\n   * @param committedRoot the latest notarized root submitted in the last signed Update\n   * @param message Raw bytes of message\n   */\n  event Dispatch(\n    bytes32 indexed messageHash,\n    uint256 indexed leafIndex,\n    uint64 indexed destinationAndNonce,\n    bytes32 committedRoot,\n    bytes message\n  );\n\n  /**\n   * @notice Emitted when proof of an improper update is submitted,\n   * which sets the contract to FAILED state\n   * @param oldRoot Old root of the improper update\n   * @param newRoot New root of the improper update\n   * @param signature Signature on `oldRoot` and `newRoot\n   */\n  event ImproperUpdate(bytes32 oldRoot, bytes32 newRoot, bytes signature);\n\n  /**\n   * @notice Emitted when the Updater is slashed\n   * (should be paired with ImproperUpdater or DoubleUpdate event)\n   * @param updater The address of the updater\n   * @param reporter The address of the entity that reported the updater misbehavior\n   */\n  event UpdaterSlashed(address indexed updater, address indexed reporter);\n\n  /**\n   * @notice Emitted when the UpdaterManager contract is changed\n   * @param updaterManager The address of the new updaterManager\n   */\n  event NewUpdaterManager(address updaterManager);\n\n  // ============ Constructor ============\n\n  constructor(uint32 _localDomain) NomadBase(_localDomain) {} // solhint-disable-line no-empty-blocks\n\n  // ============ Initializer ============\n\n  function initialize(IUpdaterManager _updaterManager) public initializer {\n    // initialize queue, set Updater Manager, and initialize\n    __QueueManager_initialize();\n    _setUpdaterManager(_updaterManager);\n    __NomadBase_initialize(updaterManager.updater());\n  }\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Ensures that function is called by the UpdaterManager contract\n   */\n  modifier onlyUpdaterManager() {\n    require(msg.sender == address(updaterManager), \"!updaterManager\");\n    _;\n  }\n\n  // ============ External: Updater & UpdaterManager Configuration  ============\n\n  /**\n   * @notice Set a new Updater\n   * @param _updater the new Updater\n   */\n  function setUpdater(address _updater) external onlyUpdaterManager {\n    _setUpdater(_updater);\n  }\n\n  /**\n   * @notice Set a new UpdaterManager contract\n   * @dev Home(s) will initially be initialized using a trusted UpdaterManager contract;\n   * we will progressively decentralize by swapping the trusted contract with a new implementation\n   * that implements Updater bonding & slashing, and rules for Updater selection & rotation\n   * @param _updaterManager the new UpdaterManager contract\n   */\n  function setUpdaterManager(address _updaterManager) external onlyOwner {\n    _setUpdaterManager(IUpdaterManager(_updaterManager));\n  }\n\n  // ============ External Functions  ============\n\n  /**\n   * @notice Dispatch the message it to the destination domain & recipient\n   * @dev Format the message, insert its hash into Merkle tree,\n   * enqueue the new Merkle root, and emit `Dispatch` event with message information.\n   * @param _destinationDomain Domain of destination chain\n   * @param _recipientAddress Address of recipient on destination chain as bytes32\n   * @param _messageBody Raw bytes content of message\n   */\n  function dispatch(\n    uint32 _destinationDomain,\n    bytes32 _recipientAddress,\n    bytes memory _messageBody\n  ) external notFailed {\n    require(_messageBody.length <= MAX_MESSAGE_BODY_BYTES, \"msg too long\");\n    // get the next nonce for the destination domain, then increment it\n    uint32 _nonce = nonces[_destinationDomain];\n    nonces[_destinationDomain] = _nonce + 1;\n    // format the message into packed bytes\n    bytes memory _message = Message.formatMessage(\n      localDomain,\n      bytes32(uint256(uint160(msg.sender))),\n      _nonce,\n      _destinationDomain,\n      _recipientAddress,\n      _messageBody\n    );\n    // insert the hashed message into the Merkle tree\n    bytes32 _messageHash = keccak256(_message);\n    tree.insert(_messageHash);\n    // enqueue the new Merkle root after inserting the message\n    queue.enqueue(root());\n    // Emit Dispatch event with message information\n    // note: leafIndex is count() - 1 since new leaf has already been inserted\n    emit Dispatch(_messageHash, count() - 1, _destinationAndNonce(_destinationDomain, _nonce), committedRoot, _message);\n  }\n\n  /**\n   * @notice Submit a signature from the Updater \"notarizing\" a root,\n   * which updates the Home contract's `committedRoot`,\n   * and publishes the signature which will be relayed to Replica contracts\n   * @dev emits Update event\n   * @dev If _newRoot is not contained in the queue,\n   * the Update is a fraudulent Improper Update, so\n   * the Updater is slashed & Home is set to FAILED state\n   * @param _committedRoot Current updated merkle root which the update is building off of\n   * @param _newRoot New merkle root to update the contract state to\n   * @param _signature Updater signature on `_committedRoot` and `_newRoot`\n   */\n  function update(\n    bytes32 _committedRoot,\n    bytes32 _newRoot,\n    bytes memory _signature\n  ) external notFailed {\n    // check that the update is not fraudulent;\n    // if fraud is detected, Updater is slashed & Home is set to FAILED state\n    if (improperUpdate(_committedRoot, _newRoot, _signature)) return;\n    // clear all of the intermediate roots contained in this update from the queue\n    while (true) {\n      bytes32 _next = queue.dequeue();\n      if (_next == _newRoot) break;\n    }\n    // update the Home state with the latest signed root & emit event\n    committedRoot = _newRoot;\n    emit Update(localDomain, _committedRoot, _newRoot, _signature);\n  }\n\n  /**\n   * @notice Suggest an update for the Updater to sign and submit.\n   * @dev If queue is empty, null bytes returned for both\n   * (No update is necessary because no messages have been dispatched since the last update)\n   * @return _committedRoot Latest root signed by the Updater\n   * @return _new Latest enqueued Merkle root\n   */\n  function suggestUpdate() external view returns (bytes32 _committedRoot, bytes32 _new) {\n    if (queue.length() != 0) {\n      _committedRoot = committedRoot;\n      _new = queue.lastItem();\n    }\n  }\n\n  // ============ Public Functions  ============\n\n  /**\n   * @notice Hash of Home domain concatenated with \"NOMAD\"\n   */\n  function homeDomainHash() public view override returns (bytes32) {\n    return _homeDomainHash(localDomain);\n  }\n\n  /**\n   * @notice Check if an Update is an Improper Update;\n   * if so, slash the Updater and set the contract to FAILED state.\n   *\n   * An Improper Update is an update building off of the Home's `committedRoot`\n   * for which the `_newRoot` does not currently exist in the Home's queue.\n   * This would mean that message(s) that were not truly\n   * dispatched on Home were falsely included in the signed root.\n   *\n   * An Improper Update will only be accepted as valid by the Replica\n   * If an Improper Update is attempted on Home,\n   * the Updater will be slashed immediately.\n   * If an Improper Update is submitted to the Replica,\n   * it should be relayed to the Home contract using this function\n   * in order to slash the Updater with an Improper Update.\n   *\n   * An Improper Update submitted to the Replica is only valid\n   * while the `_oldRoot` is still equal to the `committedRoot` on Home;\n   * if the `committedRoot` on Home has already been updated with a valid Update,\n   * then the Updater should be slashed with a Double Update.\n   * @dev Reverts (and doesn't slash updater) if signature is invalid or\n   * update not current\n   * @param _oldRoot Old merkle tree root (should equal home's committedRoot)\n   * @param _newRoot New merkle tree root\n   * @param _signature Updater signature on `_oldRoot` and `_newRoot`\n   * @return TRUE if update was an Improper Update (implying Updater was slashed)\n   */\n  function improperUpdate(\n    bytes32 _oldRoot,\n    bytes32 _newRoot,\n    bytes memory _signature\n  ) public notFailed returns (bool) {\n    require(_isUpdaterSignature(_oldRoot, _newRoot, _signature), \"!updater sig\");\n    require(_oldRoot == committedRoot, \"not a current update\");\n    // if the _newRoot is not currently contained in the queue,\n    // slash the Updater and set the contract to FAILED state\n    if (!queue.contains(_newRoot)) {\n      _fail();\n      emit ImproperUpdate(_oldRoot, _newRoot, _signature);\n      return true;\n    }\n    // if the _newRoot is contained in the queue,\n    // this is not an improper update\n    return false;\n  }\n\n  // ============ Internal Functions  ============\n\n  /**\n   * @notice Set the UpdaterManager\n   * @param _updaterManager Address of the UpdaterManager\n   */\n  function _setUpdaterManager(IUpdaterManager _updaterManager) internal {\n    require(Address.isContract(address(_updaterManager)), \"!contract updaterManager\");\n    updaterManager = IUpdaterManager(_updaterManager);\n    emit NewUpdaterManager(address(_updaterManager));\n  }\n\n  /**\n   * @notice Slash the Updater and set contract state to FAILED\n   * @dev Called when fraud is proven (Improper Update or Double Update)\n   */\n  function _fail() internal override {\n    // set contract to FAILED\n    _setFailed();\n    // slash Updater\n    updaterManager.slashUpdater(payable(msg.sender));\n    emit UpdaterSlashed(updater, msg.sender);\n  }\n\n  /**\n   * @notice Internal utility function that combines\n   * `_destination` and `_nonce`.\n   * @dev Both destination and nonce should be less than 2^32 - 1\n   * @param _destination Domain of destination chain\n   * @param _nonce Current nonce for given destination chain\n   * @return Returns (`_destination` << 32) & `_nonce`\n   */\n  function _destinationAndNonce(uint32 _destination, uint32 _nonce) internal pure returns (uint64) {\n    return (uint64(_destination) << 32) | _nonce;\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/Replica.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// ============ Internal Imports ============\nimport {Version0} from \"./Version0.sol\";\nimport {NomadBase} from \"./NomadBase.sol\";\nimport {MerkleLib} from \"../libs/Merkle.sol\";\nimport {Message} from \"../libs/Message.sol\";\n// ============ External Imports ============\n// import {TypedMemView} from \"@summa-tx/memview-sol/contracts/TypedMemView.sol\";\nimport {TypedMemView} from \"../libs/TypedMemView.sol\";\n\n/**\n * @title Replica\n * @author Illusory Systems Inc.\n * @notice Track root updates on Home,\n * prove and dispatch messages to end recipients.\n */\ncontract Replica is Version0, NomadBase {\n  // ============ Libraries ============\n\n  using MerkleLib for MerkleLib.Tree;\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n  using Message for bytes29;\n\n  // ============ Enums ============\n\n  // Status of Message:\n  //   0 - None - message has not been proven or processed\n  //   1 - Proven - message inclusion proof has been validated\n  //   2 - Processed - message has been dispatched to recipient\n  enum MessageStatus {\n    None,\n    Proven,\n    Processed\n  }\n\n  // ============ Immutables ============\n\n  // Minimum gas for message processing\n  uint256 public immutable PROCESS_GAS;\n  // Reserved gas (to ensure tx completes in case message processing runs out)\n  uint256 public immutable RESERVE_GAS;\n\n  // ============ Public Storage ============\n\n  // Domain of home chain\n  uint32 public remoteDomain;\n  // Number of seconds to wait before root becomes confirmable\n  uint256 public optimisticSeconds;\n  // re-entrancy guard\n  uint8 private entered;\n  // Mapping of roots to allowable confirmation times\n  mapping(bytes32 => uint256) public confirmAt;\n  // Mapping of message leaves to MessageStatus\n  mapping(bytes32 => MessageStatus) public messages;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[45] private __GAP;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when message is processed\n   * @param messageHash Hash of message that failed to process\n   * @param success TRUE if the call was executed successfully, FALSE if the call reverted\n   * @param returnData the return data from the external call\n   */\n  event Process(bytes32 indexed messageHash, bool indexed success, bytes indexed returnData);\n\n  /**\n   * @notice Emitted when the value for optimisticTimeout is set\n   * @param timeout The new value for optimistic timeout\n   */\n  event SetOptimisticTimeout(uint256 timeout);\n\n  /**\n   * @notice Emitted when a root's confirmation is modified by governance\n   * @param root The root for which confirmAt has been set\n   * @param previousConfirmAt The previous value of confirmAt\n   * @param newConfirmAt The new value of confirmAt\n   */\n  event SetConfirmation(bytes32 indexed root, uint256 previousConfirmAt, uint256 newConfirmAt);\n\n  // ============ Constructor ============\n\n  // solhint-disable-next-line no-empty-blocks\n  constructor(\n    uint32 _localDomain,\n    uint256 _processGas,\n    uint256 _reserveGas\n  ) NomadBase(_localDomain) {\n    require(_processGas >= 850_000, \"!process gas\");\n    require(_reserveGas >= 15_000, \"!reserve gas\");\n    PROCESS_GAS = _processGas;\n    RESERVE_GAS = _reserveGas;\n  }\n\n  // ============ Initializer ============\n\n  function initialize(\n    uint32 _remoteDomain,\n    address _updater,\n    bytes32 _committedRoot,\n    uint256 _optimisticSeconds\n  ) public initializer {\n    __NomadBase_initialize(_updater);\n    // set storage variables\n    entered = 1;\n    remoteDomain = _remoteDomain;\n    committedRoot = _committedRoot;\n    confirmAt[_committedRoot] = 1;\n    optimisticSeconds = _optimisticSeconds;\n    emit SetOptimisticTimeout(_optimisticSeconds);\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Called by external agent. Submits the signed update's new root,\n   * marks root's allowable confirmation time, and emits an `Update` event.\n   * @dev Reverts if update doesn't build off latest committedRoot\n   * or if signature is invalid.\n   * @param _oldRoot Old merkle root\n   * @param _newRoot New merkle root\n   * @param _signature Updater's signature on `_oldRoot` and `_newRoot`\n   */\n  function update(\n    bytes32 _oldRoot,\n    bytes32 _newRoot,\n    bytes memory _signature\n  ) external notFailed {\n    // ensure that update is building off the last submitted root\n    require(_oldRoot == committedRoot, \"not current update\");\n    // validate updater signature\n    require(_isUpdaterSignature(_oldRoot, _newRoot, _signature), \"!updater sig\");\n    // Hook for future use\n    _beforeUpdate();\n    // set the new root's confirmation timer\n    confirmAt[_newRoot] = block.timestamp + optimisticSeconds;\n    // update committedRoot\n    committedRoot = _newRoot;\n    emit Update(remoteDomain, _oldRoot, _newRoot, _signature);\n  }\n\n  /**\n   * @notice First attempts to prove the validity of provided formatted\n   * `message`. If the message is successfully proven, then tries to process\n   * message.\n   * @dev Reverts if `prove` call returns false\n   * @param _message Formatted message (refer to NomadBase.sol Message library)\n   * @param _proof Merkle proof of inclusion for message's leaf\n   * @param _index Index of leaf in home's merkle tree\n   */\n  function proveAndProcess(\n    bytes memory _message,\n    bytes32[32] calldata _proof,\n    uint256 _index\n  ) external {\n    require(prove(keccak256(_message), _proof, _index), \"!prove\");\n    process(_message);\n  }\n\n  /**\n   * @notice Given formatted message, attempts to dispatch\n   * message payload to end recipient.\n   * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)\n   * Reverts if formatted message's destination domain is not the Replica's domain,\n   * if message has not been proven,\n   * or if not enough gas is provided for the dispatch transaction.\n   * @param _message Formatted message\n   * @return _success TRUE iff dispatch transaction succeeded\n   */\n  function process(bytes memory _message) public returns (bool _success) {\n    bytes29 _m = _message.ref(0);\n    // ensure message was meant for this domain\n    require(_m.destination() == localDomain, \"!destination\");\n    // ensure message has been proven\n    bytes32 _messageHash = _m.keccak();\n    require(messages[_messageHash] == MessageStatus.Proven, \"!proven\");\n    // check re-entrancy guard\n    require(entered == 1, \"!reentrant\");\n    entered = 0;\n    // update message status as processed\n    messages[_messageHash] = MessageStatus.Processed;\n    // A call running out of gas TYPICALLY errors the whole tx. We want to\n    // a) ensure the call has a sufficient amount of gas to make a\n    //    meaningful state change.\n    // b) ensure that if the subcall runs out of gas, that the tx as a whole\n    //    does not revert (i.e. we still mark the message processed)\n    // To do this, we require that we have enough gas to process\n    // and still return. We then delegate only the minimum processing gas.\n    require(gasleft() >= PROCESS_GAS + RESERVE_GAS, \"!gas\");\n    // get the message recipient\n    address _recipient = _m.recipientAddress();\n    // set up for assembly call\n    uint256 _toCopy;\n    uint256 _maxCopy = 256;\n    uint256 _gas = PROCESS_GAS;\n    // allocate memory for returndata\n    bytes memory _returnData = new bytes(_maxCopy);\n    bytes memory _calldata = abi.encodeWithSignature(\n      \"handle(uint32,uint32,bytes32,bytes)\",\n      _m.origin(),\n      _m.nonce(),\n      _m.sender(),\n      _m.body().clone()\n    );\n    // dispatch message to recipient\n    // by assembly calling \"handle\" function\n    // we call via assembly to avoid memcopying a very large returndata\n    // returned by a malicious contract\n    assembly {\n      _success := call(\n        _gas, // gas\n        _recipient, // recipient\n        0, // ether value\n        add(_calldata, 0x20), // inloc\n        mload(_calldata), // inlen\n        0, // outloc\n        0 // outlen\n      )\n      // limit our copy to 256 bytes\n      _toCopy := returndatasize()\n      if gt(_toCopy, _maxCopy) {\n        _toCopy := _maxCopy\n      }\n      // Store the length of the copied bytes\n      mstore(_returnData, _toCopy)\n      // copy the bytes from returndata[0:_toCopy]\n      returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n    }\n    // emit process results\n    emit Process(_messageHash, _success, _returnData);\n    // reset re-entrancy guard\n    entered = 1;\n  }\n\n  // ============ External Owner Functions ============\n\n  /**\n   * @notice Set optimistic timeout period for new roots\n   * @dev Only callable by owner (Governance)\n   * @param _optimisticSeconds New optimistic timeout period\n   */\n  function setOptimisticTimeout(uint256 _optimisticSeconds) external onlyOwner {\n    optimisticSeconds = _optimisticSeconds;\n    emit SetOptimisticTimeout(_optimisticSeconds);\n  }\n\n  /**\n   * @notice Set Updater role\n   * @dev MUST ensure that all roots signed by previous Updater have\n   * been relayed before calling. Only callable by owner (Governance)\n   * @param _updater New Updater\n   */\n  function setUpdater(address _updater) external onlyOwner {\n    _setUpdater(_updater);\n  }\n\n  /**\n   * @notice Set confirmAt for a given root\n   * @dev To be used if in the case that fraud is proven\n   * and roots need to be deleted / added. Only callable by owner (Governance)\n   * @param _root The root for which to modify confirm time\n   * @param _confirmAt The new confirmation time. Set to 0 to \"delete\" a root.\n   */\n  function setConfirmation(bytes32 _root, uint256 _confirmAt) external onlyOwner {\n    uint256 _previousConfirmAt = confirmAt[_root];\n    confirmAt[_root] = _confirmAt;\n    emit SetConfirmation(_root, _previousConfirmAt, _confirmAt);\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Check that the root has been submitted\n   * and that the optimistic timeout period has expired,\n   * meaning the root can be processed\n   * @param _root the Merkle root, submitted in an update, to check\n   * @return TRUE iff root has been submitted & timeout has expired\n   */\n  function acceptableRoot(bytes32 _root) public view returns (bool) {\n    uint256 _time = confirmAt[_root];\n    if (_time == 0) {\n      return false;\n    }\n    return block.timestamp >= _time;\n  }\n\n  /**\n   * @notice Attempts to prove the validity of message given its leaf, the\n   * merkle proof of inclusion for the leaf, and the index of the leaf.\n   * @dev Reverts if message's MessageStatus != None (i.e. if message was\n   * already proven or processed)\n   * @dev For convenience, we allow proving against any previous root.\n   * This means that witnesses never need to be updated for the new root\n   * @param _leaf Leaf of message to prove\n   * @param _proof Merkle proof of inclusion for leaf\n   * @param _index Index of leaf in home's merkle tree\n   * @return Returns true if proof was valid and `prove` call succeeded\n   **/\n  function prove(\n    bytes32 _leaf,\n    bytes32[32] calldata _proof,\n    uint256 _index\n  ) public returns (bool) {\n    // ensure that message has not been proven or processed\n    require(messages[_leaf] == MessageStatus.None, \"!MessageStatus.None\");\n    // calculate the expected root based on the proof\n    bytes32 _calculatedRoot = MerkleLib.branchRoot(_leaf, _proof, _index);\n    // if the root is valid, change status to Proven\n    if (acceptableRoot(_calculatedRoot)) {\n      messages[_leaf] = MessageStatus.Proven;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @notice Hash of Home domain concatenated with \"NOMAD\"\n   */\n  function homeDomainHash() public view override returns (bytes32) {\n    return _homeDomainHash(remoteDomain);\n  }\n\n  // ============ Internal Functions ============\n\n  /**\n   * @notice Moves the contract into failed state\n   * @dev Called when a Double Update is submitted\n   */\n  function _fail() internal override {\n    _setFailed();\n  }\n\n  /// @notice Hook for potential future use\n  // solhint-disable-next-line no-empty-blocks\n  function _beforeUpdate() internal {}\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/libs/TypeCasts.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// import \"@summa-tx/memview-sol/contracts/TypedMemView.sol\";\nimport \"./TypedMemView.sol\";\n\nlibrary TypeCasts {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  function coerceBytes32(string memory _s) internal pure returns (bytes32 _b) {\n    _b = bytes(_s).ref(0).index(0, uint8(bytes(_s).length));\n  }\n\n  // treat it as a null-terminated string of max 32 bytes\n  function coerceString(bytes32 _buf) internal pure returns (string memory _newStr) {\n    uint8 _slen = 0;\n    while (_slen < 32 && _buf[_slen] != 0) {\n      _slen++;\n    }\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      _newStr := mload(0x40)\n      mstore(0x40, add(_newStr, 0x40)) // may end up with extra\n      mstore(_newStr, _slen)\n      mstore(add(_newStr, 0x20), _buf)\n    }\n  }\n\n  // alignment preserving cast\n  function addressToBytes32(address _addr) internal pure returns (bytes32) {\n    return bytes32(uint256(uint160(_addr)));\n  }\n\n  // alignment preserving cast\n  function bytes32ToAddress(bytes32 _buf) internal pure returns (address) {\n    return address(uint160(uint256(_buf)));\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/Version0.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n/**\n * @title Version0\n * @notice Version getter for contracts\n **/\ncontract Version0 {\n  uint8 public constant VERSION = 0;\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/NomadBase.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// ============ Internal Imports ============\nimport {Message} from \"../libs/Message.sol\";\n// ============ External Imports ============\nimport {ECDSA} from \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport {OwnableUpgradeable} from \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/**\n * @title NomadBase\n * @author Illusory Systems Inc.\n * @notice Shared utilities between Home and Replica.\n */\nabstract contract NomadBase is Initializable, OwnableUpgradeable {\n  // ============ Enums ============\n\n  // States:\n  //   0 - UnInitialized - before initialize function is called\n  //   note: the contract is initialized at deploy time, so it should never be in this state\n  //   1 - Active - as long as the contract has not become fraudulent\n  //   2 - Failed - after a valid fraud proof has been submitted;\n  //   contract will no longer accept updates or new messages\n  enum States {\n    UnInitialized,\n    Active,\n    Failed\n  }\n\n  // ============ Immutable Variables ============\n\n  // Domain of chain on which the contract is deployed\n  uint32 public immutable localDomain;\n\n  // ============ Public Variables ============\n\n  // Address of bonded Updater\n  address public updater;\n  // Current state of contract\n  States public state;\n  // The latest root that has been signed by the Updater\n  bytes32 public committedRoot;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[47] private __GAP;\n\n  // ============ Events ============\n\n  /**\n   * @notice Emitted when update is made on Home\n   * or unconfirmed update root is submitted on Replica\n   * @param homeDomain Domain of home contract\n   * @param oldRoot Old merkle root\n   * @param newRoot New merkle root\n   * @param signature Updater's signature on `oldRoot` and `newRoot`\n   */\n  event Update(uint32 indexed homeDomain, bytes32 indexed oldRoot, bytes32 indexed newRoot, bytes signature);\n\n  /**\n   * @notice Emitted when proof of a double update is submitted,\n   * which sets the contract to FAILED state\n   * @param oldRoot Old root shared between two conflicting updates\n   * @param newRoot Array containing two conflicting new roots\n   * @param signature Signature on `oldRoot` and `newRoot`[0]\n   * @param signature2 Signature on `oldRoot` and `newRoot`[1]\n   */\n  event DoubleUpdate(bytes32 oldRoot, bytes32[2] newRoot, bytes signature, bytes signature2);\n\n  /**\n   * @notice Emitted when Updater is rotated\n   * @param oldUpdater The address of the old updater\n   * @param newUpdater The address of the new updater\n   */\n  event NewUpdater(address oldUpdater, address newUpdater);\n\n  // ============ Modifiers ============\n\n  /**\n   * @notice Ensures that contract state != FAILED when the function is called\n   */\n  modifier notFailed() {\n    require(state != States.Failed, \"failed state\");\n    _;\n  }\n\n  // ============ Constructor ============\n\n  constructor(uint32 _localDomain) {\n    localDomain = _localDomain;\n  }\n\n  // ============ Initializer ============\n\n  function __NomadBase_initialize(address _updater) internal initializer {\n    __Ownable_init();\n    _setUpdater(_updater);\n    state = States.Active;\n  }\n\n  // ============ External Functions ============\n\n  /**\n   * @notice Called by external agent. Checks that signatures on two sets of\n   * roots are valid and that the new roots conflict with each other. If both\n   * cases hold true, the contract is failed and a `DoubleUpdate` event is\n   * emitted.\n   * @dev When `fail()` is called on Home, updater is slashed.\n   * @param _oldRoot Old root shared between two conflicting updates\n   * @param _newRoot Array containing two conflicting new roots\n   * @param _signature Signature on `_oldRoot` and `_newRoot`[0]\n   * @param _signature2 Signature on `_oldRoot` and `_newRoot`[1]\n   */\n  function doubleUpdate(\n    bytes32 _oldRoot,\n    bytes32[2] calldata _newRoot,\n    bytes calldata _signature,\n    bytes calldata _signature2\n  ) external notFailed {\n    if (\n      NomadBase._isUpdaterSignature(_oldRoot, _newRoot[0], _signature) &&\n      NomadBase._isUpdaterSignature(_oldRoot, _newRoot[1], _signature2) &&\n      _newRoot[0] != _newRoot[1]\n    ) {\n      _fail();\n      emit DoubleUpdate(_oldRoot, _newRoot, _signature, _signature2);\n    }\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Hash of Home domain concatenated with \"NOMAD\"\n   */\n  function homeDomainHash() public view virtual returns (bytes32);\n\n  // ============ Internal Functions ============\n\n  /**\n   * @notice Hash of Home domain concatenated with \"NOMAD\"\n   * @param _homeDomain the Home domain to hash\n   */\n  function _homeDomainHash(uint32 _homeDomain) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(_homeDomain, \"NOMAD\"));\n  }\n\n  /**\n   * @notice Set contract state to FAILED\n   * @dev Called when a valid fraud proof is submitted\n   */\n  function _setFailed() internal {\n    state = States.Failed;\n  }\n\n  /**\n   * @notice Moves the contract into failed state\n   * @dev Called when fraud is proven\n   * (Double Update is submitted on Home or Replica,\n   * or Improper Update is submitted on Home)\n   */\n  function _fail() internal virtual;\n\n  /**\n   * @notice Set the Updater\n   * @param _newUpdater Address of the new Updater\n   */\n  function _setUpdater(address _newUpdater) internal {\n    address _oldUpdater = updater;\n    updater = _newUpdater;\n    emit NewUpdater(_oldUpdater, _newUpdater);\n  }\n\n  /**\n   * @notice Checks that signature was signed by Updater\n   * @param _oldRoot Old merkle root\n   * @param _newRoot New merkle root\n   * @param _signature Signature on `_oldRoot` and `_newRoot`\n   * @return TRUE iff signature is valid signed by updater\n   **/\n  function _isUpdaterSignature(\n    bytes32 _oldRoot,\n    bytes32 _newRoot,\n    bytes memory _signature\n  ) internal view returns (bool) {\n    bytes32 _digest = keccak256(abi.encodePacked(homeDomainHash(), _oldRoot, _newRoot));\n    _digest = ECDSA.toEthSignedMessageHash(_digest);\n    return (ECDSA.recover(_digest, _signature) == updater);\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/libs/Queue.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n/**\n * @title QueueLib\n * @author Illusory Systems Inc.\n * @notice Library containing queue struct and operations for queue used by\n * Home and Replica.\n **/\nlibrary QueueLib {\n  /**\n   * @notice Queue struct\n   * @dev Internally keeps track of the `first` and `last` elements through\n   * indices and a mapping of indices to enqueued elements.\n   **/\n  struct Queue {\n    uint128 first;\n    uint128 last;\n    mapping(uint256 => bytes32) queue;\n  }\n\n  /**\n   * @notice Initializes the queue\n   * @dev Empty state denoted by _q.first > q._last. Queue initialized\n   * with _q.first = 1 and _q.last = 0.\n   **/\n  function initialize(Queue storage _q) internal {\n    if (_q.first == 0) {\n      _q.first = 1;\n    }\n  }\n\n  /**\n   * @notice Enqueues a single new element\n   * @param _item New element to be enqueued\n   * @return _last Index of newly enqueued element\n   **/\n  function enqueue(Queue storage _q, bytes32 _item) internal returns (uint128 _last) {\n    _last = _q.last + 1;\n    _q.last = _last;\n    if (_item != bytes32(0)) {\n      // saves gas if we're queueing 0\n      _q.queue[_last] = _item;\n    }\n  }\n\n  /**\n   * @notice Dequeues element at front of queue\n   * @dev Removes dequeued element from storage\n   * @return _item Dequeued element\n   **/\n  function dequeue(Queue storage _q) internal returns (bytes32 _item) {\n    uint128 _last = _q.last;\n    uint128 _first = _q.first;\n    require(_length(_last, _first) != 0, \"Empty\");\n    _item = _q.queue[_first];\n    if (_item != bytes32(0)) {\n      // saves gas if we're dequeuing 0\n      delete _q.queue[_first];\n    }\n    _q.first = _first + 1;\n  }\n\n  /**\n   * @notice Batch enqueues several elements\n   * @param _items Array of elements to be enqueued\n   * @return _last Index of last enqueued element\n   **/\n  function enqueue(Queue storage _q, bytes32[] memory _items) internal returns (uint128 _last) {\n    _last = _q.last;\n    for (uint256 i = 0; i < _items.length; i += 1) {\n      _last += 1;\n      bytes32 _item = _items[i];\n      if (_item != bytes32(0)) {\n        _q.queue[_last] = _item;\n      }\n    }\n    _q.last = _last;\n  }\n\n  /**\n   * @notice Batch dequeues `_number` elements\n   * @dev Reverts if `_number` > queue length\n   * @param _number Number of elements to dequeue\n   * @return Array of dequeued elements\n   **/\n  function dequeue(Queue storage _q, uint256 _number) internal returns (bytes32[] memory) {\n    uint128 _last = _q.last;\n    uint128 _first = _q.first;\n    // Cannot underflow unless state is corrupted\n    require(_length(_last, _first) >= _number, \"Insufficient\");\n\n    bytes32[] memory _items = new bytes32[](_number);\n\n    for (uint256 i = 0; i < _number; i++) {\n      _items[i] = _q.queue[_first];\n      delete _q.queue[_first];\n      _first++;\n    }\n    _q.first = _first;\n    return _items;\n  }\n\n  /**\n   * @notice Returns true if `_item` is in the queue and false if otherwise\n   * @dev Linearly scans from _q.first to _q.last looking for `_item`\n   * @param _item Item being searched for in queue\n   * @return True if `_item` currently exists in queue, false if otherwise\n   **/\n  function contains(Queue storage _q, bytes32 _item) internal view returns (bool) {\n    for (uint256 i = _q.first; i <= _q.last; i++) {\n      if (_q.queue[i] == _item) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /// @notice Returns last item in queue\n  /// @dev Returns bytes32(0) if queue empty\n  function lastItem(Queue storage _q) internal view returns (bytes32) {\n    return _q.queue[_q.last];\n  }\n\n  /// @notice Returns element at front of queue without removing element\n  /// @dev Reverts if queue is empty\n  function peek(Queue storage _q) internal view returns (bytes32 _item) {\n    require(!isEmpty(_q), \"Empty\");\n    _item = _q.queue[_q.first];\n  }\n\n  /// @notice Returns true if queue is empty and false if otherwise\n  function isEmpty(Queue storage _q) internal view returns (bool) {\n    return _q.last < _q.first;\n  }\n\n  /// @notice Returns number of elements in queue\n  function length(Queue storage _q) internal view returns (uint256) {\n    uint128 _last = _q.last;\n    uint128 _first = _q.first;\n    // Cannot underflow unless state is corrupted\n    return _length(_last, _first);\n  }\n\n  /// @notice Returns number of elements between `_last` and `_first` (used internally)\n  function _length(uint128 _last, uint128 _first) internal pure returns (uint256) {\n    return uint256(_last + 1 - _first);\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/libs/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// work based on eth2 deposit contract, which is used under CC0-1.0\n\n/**\n * @title MerkleLib\n * @author Illusory Systems Inc.\n * @notice An incremental merkle tree modeled on the eth2 deposit contract.\n **/\nlibrary MerkleLib {\n  uint256 internal constant TREE_DEPTH = 32;\n  uint256 internal constant MAX_LEAVES = 2**TREE_DEPTH - 1;\n\n  /**\n   * @notice Struct representing incremental merkle tree. Contains current\n   * branch and the number of inserted leaves in the tree.\n   **/\n  struct Tree {\n    bytes32[TREE_DEPTH] branch;\n    uint256 count;\n  }\n\n  /**\n   * @notice Inserts `_node` into merkle tree\n   * @dev Reverts if tree is full\n   * @param _node Element to insert into tree\n   **/\n  function insert(Tree storage _tree, bytes32 _node) internal {\n    require(_tree.count < MAX_LEAVES, \"merkle tree full\");\n\n    _tree.count += 1;\n    uint256 size = _tree.count;\n    for (uint256 i = 0; i < TREE_DEPTH; i++) {\n      if ((size & 1) == 1) {\n        _tree.branch[i] = _node;\n        return;\n      }\n      _node = keccak256(abi.encodePacked(_tree.branch[i], _node));\n      size /= 2;\n    }\n    // As the loop should always end prematurely with the `return` statement,\n    // this code should be unreachable. We assert `false` just to be safe.\n    assert(false);\n  }\n\n  /**\n   * @notice Calculates and returns`_tree`'s current root given array of zero\n   * hashes\n   * @param _zeroes Array of zero hashes\n   * @return _current Calculated root of `_tree`\n   **/\n  function rootWithCtx(Tree storage _tree, bytes32[TREE_DEPTH] memory _zeroes)\n    internal\n    view\n    returns (bytes32 _current)\n  {\n    uint256 _index = _tree.count;\n\n    for (uint256 i = 0; i < TREE_DEPTH; i++) {\n      uint256 _ithBit = (_index >> i) & 0x01;\n      bytes32 _next = _tree.branch[i];\n      if (_ithBit == 1) {\n        _current = keccak256(abi.encodePacked(_next, _current));\n      } else {\n        _current = keccak256(abi.encodePacked(_current, _zeroes[i]));\n      }\n    }\n  }\n\n  /// @notice Calculates and returns`_tree`'s current root\n  function root(Tree storage _tree) internal view returns (bytes32) {\n    return rootWithCtx(_tree, zeroHashes());\n  }\n\n  /// @notice Returns array of TREE_DEPTH zero hashes\n  /// @return _zeroes Array of TREE_DEPTH zero hashes\n  function zeroHashes() internal pure returns (bytes32[TREE_DEPTH] memory _zeroes) {\n    _zeroes[0] = Z_0;\n    _zeroes[1] = Z_1;\n    _zeroes[2] = Z_2;\n    _zeroes[3] = Z_3;\n    _zeroes[4] = Z_4;\n    _zeroes[5] = Z_5;\n    _zeroes[6] = Z_6;\n    _zeroes[7] = Z_7;\n    _zeroes[8] = Z_8;\n    _zeroes[9] = Z_9;\n    _zeroes[10] = Z_10;\n    _zeroes[11] = Z_11;\n    _zeroes[12] = Z_12;\n    _zeroes[13] = Z_13;\n    _zeroes[14] = Z_14;\n    _zeroes[15] = Z_15;\n    _zeroes[16] = Z_16;\n    _zeroes[17] = Z_17;\n    _zeroes[18] = Z_18;\n    _zeroes[19] = Z_19;\n    _zeroes[20] = Z_20;\n    _zeroes[21] = Z_21;\n    _zeroes[22] = Z_22;\n    _zeroes[23] = Z_23;\n    _zeroes[24] = Z_24;\n    _zeroes[25] = Z_25;\n    _zeroes[26] = Z_26;\n    _zeroes[27] = Z_27;\n    _zeroes[28] = Z_28;\n    _zeroes[29] = Z_29;\n    _zeroes[30] = Z_30;\n    _zeroes[31] = Z_31;\n  }\n\n  /**\n   * @notice Calculates and returns the merkle root for the given leaf\n   * `_item`, a merkle branch, and the index of `_item` in the tree.\n   * @param _item Merkle leaf\n   * @param _branch Merkle proof\n   * @param _index Index of `_item` in tree\n   * @return _current Calculated merkle root\n   **/\n  function branchRoot(\n    bytes32 _item,\n    bytes32[TREE_DEPTH] memory _branch,\n    uint256 _index\n  ) internal pure returns (bytes32 _current) {\n    _current = _item;\n\n    for (uint256 i = 0; i < TREE_DEPTH; i++) {\n      uint256 _ithBit = (_index >> i) & 0x01;\n      bytes32 _next = _branch[i];\n      if (_ithBit == 1) {\n        _current = keccak256(abi.encodePacked(_next, _current));\n      } else {\n        _current = keccak256(abi.encodePacked(_current, _next));\n      }\n    }\n  }\n\n  // keccak256 zero hashes\n  bytes32 internal constant Z_0 = hex\"0000000000000000000000000000000000000000000000000000000000000000\";\n  bytes32 internal constant Z_1 = hex\"ad3228b676f7d3cd4284a5443f17f1962b36e491b30a40b2405849e597ba5fb5\";\n  bytes32 internal constant Z_2 = hex\"b4c11951957c6f8f642c4af61cd6b24640fec6dc7fc607ee8206a99e92410d30\";\n  bytes32 internal constant Z_3 = hex\"21ddb9a356815c3fac1026b6dec5df3124afbadb485c9ba5a3e3398a04b7ba85\";\n  bytes32 internal constant Z_4 = hex\"e58769b32a1beaf1ea27375a44095a0d1fb664ce2dd358e7fcbfb78c26a19344\";\n  bytes32 internal constant Z_5 = hex\"0eb01ebfc9ed27500cd4dfc979272d1f0913cc9f66540d7e8005811109e1cf2d\";\n  bytes32 internal constant Z_6 = hex\"887c22bd8750d34016ac3c66b5ff102dacdd73f6b014e710b51e8022af9a1968\";\n  bytes32 internal constant Z_7 = hex\"ffd70157e48063fc33c97a050f7f640233bf646cc98d9524c6b92bcf3ab56f83\";\n  bytes32 internal constant Z_8 = hex\"9867cc5f7f196b93bae1e27e6320742445d290f2263827498b54fec539f756af\";\n  bytes32 internal constant Z_9 = hex\"cefad4e508c098b9a7e1d8feb19955fb02ba9675585078710969d3440f5054e0\";\n  bytes32 internal constant Z_10 = hex\"f9dc3e7fe016e050eff260334f18a5d4fe391d82092319f5964f2e2eb7c1c3a5\";\n  bytes32 internal constant Z_11 = hex\"f8b13a49e282f609c317a833fb8d976d11517c571d1221a265d25af778ecf892\";\n  bytes32 internal constant Z_12 = hex\"3490c6ceeb450aecdc82e28293031d10c7d73bf85e57bf041a97360aa2c5d99c\";\n  bytes32 internal constant Z_13 = hex\"c1df82d9c4b87413eae2ef048f94b4d3554cea73d92b0f7af96e0271c691e2bb\";\n  bytes32 internal constant Z_14 = hex\"5c67add7c6caf302256adedf7ab114da0acfe870d449a3a489f781d659e8becc\";\n  bytes32 internal constant Z_15 = hex\"da7bce9f4e8618b6bd2f4132ce798cdc7a60e7e1460a7299e3c6342a579626d2\";\n  bytes32 internal constant Z_16 = hex\"2733e50f526ec2fa19a22b31e8ed50f23cd1fdf94c9154ed3a7609a2f1ff981f\";\n  bytes32 internal constant Z_17 = hex\"e1d3b5c807b281e4683cc6d6315cf95b9ade8641defcb32372f1c126e398ef7a\";\n  bytes32 internal constant Z_18 = hex\"5a2dce0a8a7f68bb74560f8f71837c2c2ebbcbf7fffb42ae1896f13f7c7479a0\";\n  bytes32 internal constant Z_19 = hex\"b46a28b6f55540f89444f63de0378e3d121be09e06cc9ded1c20e65876d36aa0\";\n  bytes32 internal constant Z_20 = hex\"c65e9645644786b620e2dd2ad648ddfcbf4a7e5b1a3a4ecfe7f64667a3f0b7e2\";\n  bytes32 internal constant Z_21 = hex\"f4418588ed35a2458cffeb39b93d26f18d2ab13bdce6aee58e7b99359ec2dfd9\";\n  bytes32 internal constant Z_22 = hex\"5a9c16dc00d6ef18b7933a6f8dc65ccb55667138776f7dea101070dc8796e377\";\n  bytes32 internal constant Z_23 = hex\"4df84f40ae0c8229d0d6069e5c8f39a7c299677a09d367fc7b05e3bc380ee652\";\n  bytes32 internal constant Z_24 = hex\"cdc72595f74c7b1043d0e1ffbab734648c838dfb0527d971b602bc216c9619ef\";\n  bytes32 internal constant Z_25 = hex\"0abf5ac974a1ed57f4050aa510dd9c74f508277b39d7973bb2dfccc5eeb0618d\";\n  bytes32 internal constant Z_26 = hex\"b8cd74046ff337f0a7bf2c8e03e10f642c1886798d71806ab1e888d9e5ee87d0\";\n  bytes32 internal constant Z_27 = hex\"838c5655cb21c6cb83313b5a631175dff4963772cce9108188b34ac87c81c41e\";\n  bytes32 internal constant Z_28 = hex\"662ee4dd2dd7b2bc707961b1e646c4047669dcb6584f0d8d770daf5d7e7deb2e\";\n  bytes32 internal constant Z_29 = hex\"388ab20e2573d171a88108e79d820e98f26c0b84aa8b2f4aa4968dbb818ea322\";\n  bytes32 internal constant Z_30 = hex\"93237c50ba75ee485f4c22adf2f741400bdf8d6a9cc7df7ecae576221665d735\";\n  bytes32 internal constant Z_31 = hex\"8448818bb4ae4562849e949e17ac16e0be16688e156b5cf15e098c627c0056a9\";\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/libs/Message.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// import \"@summa-tx/memview-sol/contracts/TypedMemView.sol\";\n\nimport \"./TypedMemView.sol\";\n\nimport {TypeCasts} from \"./TypeCasts.sol\";\n\n/**\n * @title Message Library\n * @author Illusory Systems Inc.\n * @notice Library for formatted messages used by Home and Replica.\n **/\nlibrary Message {\n  using TypedMemView for bytes;\n  using TypedMemView for bytes29;\n\n  // Number of bytes in formatted message before `body` field\n  uint256 internal constant PREFIX_LENGTH = 76;\n\n  /**\n   * @notice Returns formatted (packed) message with provided fields\n   * @param _originDomain Domain of home chain\n   * @param _sender Address of sender as bytes32\n   * @param _nonce Destination-specific nonce\n   * @param _destinationDomain Domain of destination chain\n   * @param _recipient Address of recipient on destination chain as bytes32\n   * @param _messageBody Raw bytes of message body\n   * @return Formatted message\n   **/\n  function formatMessage(\n    uint32 _originDomain,\n    bytes32 _sender,\n    uint32 _nonce,\n    uint32 _destinationDomain,\n    bytes32 _recipient,\n    bytes memory _messageBody\n  ) internal pure returns (bytes memory) {\n    return abi.encodePacked(_originDomain, _sender, _nonce, _destinationDomain, _recipient, _messageBody);\n  }\n\n  /**\n   * @notice Returns leaf of formatted message with provided fields.\n   * @param _origin Domain of home chain\n   * @param _sender Address of sender as bytes32\n   * @param _nonce Destination-specific nonce number\n   * @param _destination Domain of destination chain\n   * @param _recipient Address of recipient on destination chain as bytes32\n   * @param _body Raw bytes of message body\n   * @return Leaf (hash) of formatted message\n   **/\n  function messageHash(\n    uint32 _origin,\n    bytes32 _sender,\n    uint32 _nonce,\n    uint32 _destination,\n    bytes32 _recipient,\n    bytes memory _body\n  ) internal pure returns (bytes32) {\n    return keccak256(formatMessage(_origin, _sender, _nonce, _destination, _recipient, _body));\n  }\n\n  /// @notice Returns message's origin field\n  function origin(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(0, 4));\n  }\n\n  /// @notice Returns message's sender field\n  function sender(bytes29 _message) internal pure returns (bytes32) {\n    return _message.index(4, 32);\n  }\n\n  /// @notice Returns message's nonce field\n  function nonce(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(36, 4));\n  }\n\n  /// @notice Returns message's destination field\n  function destination(bytes29 _message) internal pure returns (uint32) {\n    return uint32(_message.indexUint(40, 4));\n  }\n\n  /// @notice Returns message's recipient field as bytes32\n  function recipient(bytes29 _message) internal pure returns (bytes32) {\n    return _message.index(44, 32);\n  }\n\n  /// @notice Returns message's recipient field as an address\n  function recipientAddress(bytes29 _message) internal pure returns (address) {\n    return TypeCasts.bytes32ToAddress(recipient(_message));\n  }\n\n  /// @notice Returns message's body field as bytes29 (refer to TypedMemView library for details on bytes29 type)\n  function body(bytes29 _message) internal pure returns (bytes29) {\n    return _message.slice(PREFIX_LENGTH, _message.len() - PREFIX_LENGTH, 0);\n  }\n\n  function leaf(bytes29 _message) internal view returns (bytes32) {\n    return\n      messageHash(\n        origin(_message),\n        sender(_message),\n        nonce(_message),\n        destination(_message),\n        recipient(_message),\n        TypedMemView.clone(body(_message))\n      );\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/Merkle.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// ============ Internal Imports ============\nimport {MerkleLib} from \"../libs/Merkle.sol\";\n\n/**\n * @title MerkleTreeManager\n * @author Illusory Systems Inc.\n * @notice Contains a Merkle tree instance and\n * exposes view functions for the tree.\n */\ncontract MerkleTreeManager {\n  // ============ Libraries ============\n\n  using MerkleLib for MerkleLib.Tree;\n  MerkleLib.Tree public tree;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[49] private __GAP;\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Calculates and returns tree's current root\n   */\n  function root() public view returns (bytes32) {\n    return tree.root();\n  }\n\n  /**\n   * @notice Returns the number of inserted leaves in the tree (current index)\n   */\n  function count() public view returns (uint256) {\n    return tree.count;\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/contracts/Queue.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\n// ============ Internal Imports ============\nimport {QueueLib} from \"../libs/Queue.sol\";\n// ============ External Imports ============\nimport {Initializable} from \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\n\n/**\n * @title QueueManager\n * @author Illusory Systems Inc.\n * @notice Contains a queue instance and\n * exposes view functions for the queue.\n **/\ncontract QueueManager is Initializable {\n  // ============ Libraries ============\n\n  using QueueLib for QueueLib.Queue;\n  QueueLib.Queue internal queue;\n\n  // ============ Upgrade Gap ============\n\n  // gap for upgrade safety\n  uint256[49] private __GAP;\n\n  // ============ Initializer ============\n\n  function __QueueManager_initialize() internal initializer {\n    queue.initialize();\n  }\n\n  // ============ Public Functions ============\n\n  /**\n   * @notice Returns number of elements in queue\n   */\n  function queueLength() external view returns (uint256) {\n    return queue.length();\n  }\n\n  /**\n   * @notice Returns TRUE iff `_item` is in the queue\n   */\n  function queueContains(bytes32 _item) external view returns (bool) {\n    return queue.contains(_item);\n  }\n\n  /**\n   * @notice Returns last item enqueued to the queue\n   */\n  function queueEnd() external view returns (bytes32) {\n    return queue.lastItem();\n  }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/interfaces/IUpdaterManager.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\ninterface IUpdaterManager {\n  function slashUpdater(address payable _reporter) external;\n\n  function updater() external view returns (address);\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/libs/TypedMemView.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.8.11;\n\nlibrary TypedMemView {\n  // Why does this exist?\n  // the solidity `bytes memory` type has a few weaknesses.\n  // 1. You can't index ranges effectively\n  // 2. You can't slice without copying\n  // 3. The underlying data may represent any type\n  // 4. Solidity never deallocates memory, and memory costs grow\n  //    superlinearly\n\n  // By using a memory view instead of a `bytes memory` we get the following\n  // advantages:\n  // 1. Slices are done on the stack, by manipulating the pointer\n  // 2. We can index arbitrary ranges and quickly convert them to stack types\n  // 3. We can insert type info into the pointer, and typecheck at runtime\n\n  // This makes `TypedMemView` a useful tool for efficient zero-copy\n  // algorithms.\n\n  // Why bytes29?\n  // We want to avoid confusion between views, digests, and other common\n  // types so we chose a large and uncommonly used odd number of bytes\n  //\n  // Note that while bytes are left-aligned in a word, integers and addresses\n  // are right-aligned. This means when working in assembly we have to\n  // account for the 3 unused bytes on the righthand side\n  //\n  // First 5 bytes are a type flag.\n  // - ff_ffff_fffe is reserved for unknown type.\n  // - ff_ffff_ffff is reserved for invalid types/errors.\n  // next 12 are memory address\n  // next 12 are len\n  // bottom 3 bytes are empty\n\n  // Assumptions:\n  // - non-modification of memory.\n  // - No Solidity updates\n  // - - wrt free mem point\n  // - - wrt bytes representation in memory\n  // - - wrt memory addressing in general\n\n  // Usage:\n  // - create type constants\n  // - use `assertType` for runtime type assertions\n  // - - unfortunately we can't do this at compile time yet :(\n  // - recommended: implement modifiers that perform type checking\n  // - - e.g.\n  // - - `uint40 constant MY_TYPE = 3;`\n  // - - ` modifer onlyMyType(bytes29 myView) { myView.assertType(MY_TYPE); }`\n  // - instantiate a typed view from a bytearray using `ref`\n  // - use `index` to inspect the contents of the view\n  // - use `slice` to create smaller views into the same memory\n  // - - `slice` can increase the offset\n  // - - `slice can decrease the length`\n  // - - must specify the output type of `slice`\n  // - - `slice` will return a null view if you try to overrun\n  // - - make sure to explicitly check for this with `notNull` or `assertType`\n  // - use `equal` for typed comparisons.\n\n  // The null view\n  bytes29 public constant NULL = hex\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\";\n  uint256 constant LOW_12_MASK = 0xffffffffffffffffffffffff;\n  uint8 constant TWELVE_BYTES = 96;\n\n  /**\n   * @notice      Returns the encoded hex character that represents the lower 4 bits of the argument.\n   * @param _b    The byte\n   * @return      char - The encoded hex character\n   */\n  function nibbleHex(uint8 _b) internal pure returns (uint8 char) {\n    // This can probably be done more efficiently, but it's only in error\n    // paths, so we don't really care :)\n    uint8 _nibble = _b | 0xf0; // set top 4, keep bottom 4\n    if (_nibble == 0xf0) {\n      return 0x30;\n    } // 0\n    if (_nibble == 0xf1) {\n      return 0x31;\n    } // 1\n    if (_nibble == 0xf2) {\n      return 0x32;\n    } // 2\n    if (_nibble == 0xf3) {\n      return 0x33;\n    } // 3\n    if (_nibble == 0xf4) {\n      return 0x34;\n    } // 4\n    if (_nibble == 0xf5) {\n      return 0x35;\n    } // 5\n    if (_nibble == 0xf6) {\n      return 0x36;\n    } // 6\n    if (_nibble == 0xf7) {\n      return 0x37;\n    } // 7\n    if (_nibble == 0xf8) {\n      return 0x38;\n    } // 8\n    if (_nibble == 0xf9) {\n      return 0x39;\n    } // 9\n    if (_nibble == 0xfa) {\n      return 0x61;\n    } // a\n    if (_nibble == 0xfb) {\n      return 0x62;\n    } // b\n    if (_nibble == 0xfc) {\n      return 0x63;\n    } // c\n    if (_nibble == 0xfd) {\n      return 0x64;\n    } // d\n    if (_nibble == 0xfe) {\n      return 0x65;\n    } // e\n    if (_nibble == 0xff) {\n      return 0x66;\n    } // f\n  }\n\n  /**\n   * @notice      Returns a uint16 containing the hex-encoded byte.\n   * @param _b    The byte\n   * @return      encoded - The hex-encoded byte\n   */\n  function byteHex(uint8 _b) internal pure returns (uint16 encoded) {\n    encoded |= nibbleHex(_b >> 4); // top 4 bits\n    encoded <<= 8;\n    encoded |= nibbleHex(_b); // lower 4 bits\n  }\n\n  /**\n   * @notice      Encodes the uint256 to hex. `first` contains the encoded top 16 bytes.\n   *              `second` contains the encoded lower 16 bytes.\n   *\n   * @param _b    The 32 bytes as uint256\n   * @return      first - The top 16 bytes\n   * @return      second - The bottom 16 bytes\n   */\n  function encodeHex(uint256 _b) internal pure returns (uint256 first, uint256 second) {\n    for (uint8 i = 31; i > 15; ) {\n      uint8 _byte = uint8(_b >> (i * 8));\n      first |= byteHex(_byte);\n      if (i != 16) {\n        first <<= 16;\n      }\n      unchecked {\n        i -= 1;\n      }\n    }\n\n    // abusing underflow here =_=\n    for (uint8 i = 15; i < 255; ) {\n      uint8 _byte = uint8(_b >> (i * 8));\n      second |= byteHex(_byte);\n      if (i != 0) {\n        second <<= 16;\n      }\n      unchecked {\n        i -= 1;\n      }\n    }\n  }\n\n  /**\n   * @notice          Changes the endianness of a uint256.\n   * @dev             https://graphics.stanford.edu/~seander/bithacks.html#ReverseParallel\n   * @param _b        The unsigned integer to reverse\n   * @return          v - The reversed value\n   */\n  function reverseUint256(uint256 _b) internal pure returns (uint256 v) {\n    v = _b;\n\n    // swap bytes\n    v =\n      ((v >> 8) & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) |\n      ((v & 0x00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF00FF) << 8);\n    // swap 2-byte long pairs\n    v =\n      ((v >> 16) & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) |\n      ((v & 0x0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF0000FFFF) << 16);\n    // swap 4-byte long pairs\n    v =\n      ((v >> 32) & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) |\n      ((v & 0x00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF00000000FFFFFFFF) << 32);\n    // swap 8-byte long pairs\n    v =\n      ((v >> 64) & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) |\n      ((v & 0x0000000000000000FFFFFFFFFFFFFFFF0000000000000000FFFFFFFFFFFFFFFF) << 64);\n    // swap 16-byte long pairs\n    v = (v >> 128) | (v << 128);\n  }\n\n  /**\n   * @notice      Create a mask with the highest `_len` bits set.\n   * @param _len  The length\n   * @return      mask - The mask\n   */\n  function leftMask(uint8 _len) private pure returns (uint256 mask) {\n    // ugly. redo without assembly?\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mask := sar(sub(_len, 1), 0x8000000000000000000000000000000000000000000000000000000000000000)\n    }\n  }\n\n  /**\n   * @notice      Return the null view.\n   * @return      bytes29 - The null view\n   */\n  function nullView() internal pure returns (bytes29) {\n    return NULL;\n  }\n\n  /**\n   * @notice      Check if the view is null.\n   * @return      bool - True if the view is null\n   */\n  function isNull(bytes29 memView) internal pure returns (bool) {\n    return memView == NULL;\n  }\n\n  /**\n   * @notice      Check if the view is not null.\n   * @return      bool - True if the view is not null\n   */\n  function notNull(bytes29 memView) internal pure returns (bool) {\n    return !isNull(memView);\n  }\n\n  /**\n   * @notice          Check if the view is of a valid type and points to a valid location\n   *                  in memory.\n   * @dev             We perform this check by examining solidity's unallocated memory\n   *                  pointer and ensuring that the view's upper bound is less than that.\n   * @param memView   The view\n   * @return          ret - True if the view is valid\n   */\n  function isValid(bytes29 memView) internal pure returns (bool ret) {\n    if (typeOf(memView) == 0xffffffffff) {\n      return false;\n    }\n    uint256 _end = end(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ret := not(gt(_end, mload(0x40)))\n    }\n  }\n\n  /**\n   * @notice          Require that a typed memory view be valid.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @return          bytes29 - The validated view\n   */\n  function assertValid(bytes29 memView) internal pure returns (bytes29) {\n    require(isValid(memView), \"Validity assertion failed\");\n    return memView;\n  }\n\n  /**\n   * @notice          Return true if the memview is of the expected type. Otherwise false.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bool - True if the memview is of the expected type\n   */\n  function isType(bytes29 memView, uint40 _expected) internal pure returns (bool) {\n    return typeOf(memView) == _expected;\n  }\n\n  /**\n   * @notice          Require that a typed memory view has a specific type.\n   * @dev             Returns the view for easy chaining.\n   * @param memView   The view\n   * @param _expected The expected type\n   * @return          bytes29 - The view with validated type\n   */\n  function assertType(bytes29 memView, uint40 _expected) internal pure returns (bytes29) {\n    if (!isType(memView, _expected)) {\n      (, uint256 g) = encodeHex(uint256(typeOf(memView)));\n      (, uint256 e) = encodeHex(uint256(_expected));\n      string memory err = string(\n        abi.encodePacked(\"Type assertion failed. Got 0x\", uint80(g), \". Expected 0x\", uint80(e))\n      );\n      revert(err);\n    }\n    return memView;\n  }\n\n  /**\n   * @notice          Return an identical view with a different type.\n   * @param memView   The view\n   * @param _newType  The new type\n   * @return          newView - The new view with the specified type\n   */\n  function castTo(bytes29 memView, uint40 _newType) internal pure returns (bytes29 newView) {\n    // then | in the new type\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // shift off the top 5 bytes\n      newView := or(newView, shr(40, shl(40, memView)))\n      newView := or(newView, shl(216, _newType))\n    }\n  }\n\n  /**\n   * @notice          Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Unsafe raw pointer construction. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function unsafeBuildUnchecked(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) private pure returns (bytes29 newView) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      newView := shl(96, or(newView, _type)) // insert type\n      newView := shl(96, or(newView, _loc)) // insert loc\n      newView := shl(24, or(newView, _len)) // empty bottom 3 bytes\n    }\n  }\n\n  /**\n   * @notice          Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @dev             Instantiate a new memory view. This should generally not be called\n   *                  directly. Prefer `ref` wherever possible.\n   * @param _type     The type\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @return          newView - The new view with the specified type, location and length\n   */\n  function build(\n    uint256 _type,\n    uint256 _loc,\n    uint256 _len\n  ) internal pure returns (bytes29 newView) {\n    uint256 _end = _loc + _len;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      if gt(_end, mload(0x40)) {\n        _end := 0\n      }\n    }\n    if (_end == 0) {\n      return NULL;\n    }\n    newView = unsafeBuildUnchecked(_type, _loc, _len);\n  }\n\n  /**\n   * @notice          Instantiate a memory view from a byte array.\n   * @dev             Note that due to Solidity memory representation, it is not possible to\n   *                  implement a deref, as the `bytes` type stores its len in memory.\n   * @param arr       The byte array\n   * @param newType   The type\n   * @return          bytes29 - The memory view\n   */\n  function ref(bytes memory arr, uint40 newType) internal pure returns (bytes29) {\n    uint256 _len = arr.length;\n\n    uint256 _loc;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _loc := add(arr, 0x20) // our view is of the data, not the struct\n    }\n\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Return the associated type information.\n   * @param memView   The memory view\n   * @return          _type - The type associated with the view\n   */\n  function typeOf(bytes29 memView) internal pure returns (uint40 _type) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 216 == 256 - 40\n      _type := shr(216, memView) // shift out lower 24 bytes\n    }\n  }\n\n  /**\n   * @notice          Optimized type comparison. Checks that the 5-byte type flag is equal.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the 5-byte type flag is equal\n   */\n  function sameType(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return (left ^ right) >> (2 * TWELVE_BYTES) == 0;\n  }\n\n  /**\n   * @notice          Return the memory address of the underlying bytes.\n   * @param memView   The view\n   * @return          _loc - The memory address\n   */\n  function loc(bytes29 memView) internal pure returns (uint96 _loc) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // 120 bits = 12 bytes (the encoded loc) + 3 bytes (empty low space)\n      _loc := and(shr(120, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          The number of memory words this memory view occupies, rounded up.\n   * @param memView   The view\n   * @return          uint256 - The number of memory words\n   */\n  function words(bytes29 memView) internal pure returns (uint256) {\n    return (uint256(len(memView)) + 32) / 32;\n  }\n\n  /**\n   * @notice          The in-memory footprint of a fresh copy of the view.\n   * @param memView   The view\n   * @return          uint256 - The in-memory footprint of a fresh copy of the view.\n   */\n  function footprint(bytes29 memView) internal pure returns (uint256) {\n    return words(memView) * 32;\n  }\n\n  /**\n   * @notice          The number of bytes of the view.\n   * @param memView   The view\n   * @return          _len - The length of the view\n   */\n  function len(bytes29 memView) internal pure returns (uint96 _len) {\n    uint256 _mask = LOW_12_MASK; // assembly can't use globals\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      _len := and(shr(24, memView), _mask)\n    }\n  }\n\n  /**\n   * @notice          Returns the endpoint of `memView`.\n   * @param memView   The view\n   * @return          uint256 - The endpoint of `memView`\n   */\n  function end(bytes29 memView) internal pure returns (uint256) {\n    unchecked {\n      return loc(memView) + len(memView);\n    }\n  }\n\n  /**\n   * @notice          Safe slicing without memory modification.\n   * @param memView   The view\n   * @param _index    The start index\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function slice(\n    bytes29 memView,\n    uint256 _index,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    uint256 _loc = loc(memView);\n\n    // Ensure it doesn't overrun the view\n    if (_loc + _index + _len > end(memView)) {\n      return NULL;\n    }\n\n    _loc = _loc + _index;\n    return build(newType, _loc, _len);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the first `_len` bytes.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function prefix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, 0, _len, newType);\n  }\n\n  /**\n   * @notice          Shortcut to `slice`. Gets a view representing the last `_len` byte.\n   * @param memView   The view\n   * @param _len      The length\n   * @param newType   The new type\n   * @return          bytes29 - The new view\n   */\n  function postfix(\n    bytes29 memView,\n    uint256 _len,\n    uint40 newType\n  ) internal pure returns (bytes29) {\n    return slice(memView, uint256(len(memView)) - _len, _len, newType);\n  }\n\n  /**\n   * @notice          Construct an error message for an indexing overrun.\n   * @param _loc      The memory address\n   * @param _len      The length\n   * @param _index    The index\n   * @param _slice    The slice where the overrun occurred\n   * @return          err - The err\n   */\n  function indexErrOverrun(\n    uint256 _loc,\n    uint256 _len,\n    uint256 _index,\n    uint256 _slice\n  ) internal pure returns (string memory err) {\n    (, uint256 a) = encodeHex(_loc);\n    (, uint256 b) = encodeHex(_len);\n    (, uint256 c) = encodeHex(_index);\n    (, uint256 d) = encodeHex(_slice);\n    err = string(\n      abi.encodePacked(\n        \"TypedMemView/index - Overran the view. Slice is at 0x\",\n        uint48(a),\n        \" with length 0x\",\n        uint48(b),\n        \". Attempted to index at offset 0x\",\n        uint48(c),\n        \" with length 0x\",\n        uint48(d),\n        \".\"\n      )\n    );\n  }\n\n  /**\n   * @notice          Load up to 32 bytes from the view onto the stack.\n   * @dev             Returns a bytes32 with only the `_bytes` highest bytes set.\n   *                  This can be immediately cast to a smaller fixed-length byte array.\n   *                  To automatically cast to an integer, use `indexUint`.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The 32 byte result\n   */\n  function index(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (bytes32 result) {\n    if (_bytes == 0) {\n      return bytes32(0);\n    }\n    if (_index + _bytes > len(memView)) {\n      revert(indexErrOverrun(loc(memView), len(memView), _index, uint256(_bytes)));\n    }\n    require(_bytes <= 32, \"TypedMemView/index - Attempted to index more than 32 bytes\");\n\n    uint8 bitLength;\n    unchecked {\n      bitLength = _bytes * 8;\n    }\n    uint256 _loc = loc(memView);\n    uint256 _mask = leftMask(bitLength);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      result := and(mload(add(_loc, _index)), _mask)\n    }\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from the view at `_index`.\n   * @dev             Requires that the view have >= `_bytes` bytes following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return uint256(index(memView, _index, _bytes)) >> ((32 - _bytes) * 8);\n  }\n\n  /**\n   * @notice          Parse an unsigned integer from LE bytes.\n   * @param memView   The view\n   * @param _index    The index\n   * @param _bytes    The bytes\n   * @return          result - The unsigned integer\n   */\n  function indexLEUint(\n    bytes29 memView,\n    uint256 _index,\n    uint8 _bytes\n  ) internal pure returns (uint256 result) {\n    return reverseUint256(uint256(index(memView, _index, _bytes)));\n  }\n\n  /**\n   * @notice          Parse an address from the view at `_index`. Requires that the view have >= 20 bytes\n   *                  following that index.\n   * @param memView   The view\n   * @param _index    The index\n   * @return          address - The address\n   */\n  function indexAddress(bytes29 memView, uint256 _index) internal pure returns (address) {\n    return address(uint160(indexUint(memView, _index, 20)));\n  }\n\n  /**\n   * @notice          Return the keccak256 hash of the underlying memory\n   * @param memView   The view\n   * @return          digest - The keccak256 hash of the underlying memory\n   */\n  function keccak(bytes29 memView) internal pure returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      digest := keccak256(_loc, _len)\n    }\n  }\n\n  /**\n   * @notice          Return the sha2 digest of the underlying memory.\n   * @dev             We explicitly deallocate memory afterwards.\n   * @param memView   The view\n   * @return          digest - The sha2 hash of the underlying memory\n   */\n  function sha2(bytes29 memView) internal view returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n      digest := mload(ptr)\n    }\n  }\n\n  /**\n   * @notice          Implements bitcoin's hash160 (rmd160(sha2()))\n   * @param memView   The pre-image\n   * @return          digest - the Digest\n   */\n  function hash160(bytes29 memView) internal view returns (bytes20 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2\n      pop(staticcall(gas(), 3, ptr, 0x20, ptr, 0x20)) // rmd160\n      digest := mload(add(ptr, 0xc)) // return value is 0-prefixed.\n    }\n  }\n\n  /**\n   * @notice          Implements bitcoin's hash256 (double sha2)\n   * @param memView   A view of the preimage\n   * @return          digest - the Digest\n   */\n  function hash256(bytes29 memView) internal view returns (bytes32 digest) {\n    uint256 _loc = loc(memView);\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      pop(staticcall(gas(), 2, _loc, _len, ptr, 0x20)) // sha2 #1\n      pop(staticcall(gas(), 2, ptr, 0x20, ptr, 0x20)) // sha2 #2\n      digest := mload(ptr)\n    }\n  }\n\n  /**\n   * @notice          Return true if the underlying memory is equal. Else false.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the underlying memory is equal\n   */\n  function untypedEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return (loc(left) == loc(right) && len(left) == len(right)) || keccak(left) == keccak(right);\n  }\n\n  /**\n   * @notice          Return false if the underlying memory is equal. Else true.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - False if the underlying memory is equal\n   */\n  function untypedNotEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !untypedEqual(left, right);\n  }\n\n  /**\n   * @notice          Compares type equality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are the same\n   */\n  function equal(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return left == right || (typeOf(left) == typeOf(right) && keccak(left) == keccak(right));\n  }\n\n  /**\n   * @notice          Compares type inequality.\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param left      The first view\n   * @param right     The second view\n   * @return          bool - True if the types are not the same\n   */\n  function notEqual(bytes29 left, bytes29 right) internal pure returns (bool) {\n    return !equal(left, right);\n  }\n\n  /**\n   * @notice          Copy the view to a location, return an unsafe memory reference\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memView   The view\n   * @param _newLoc   The new location\n   * @return          written - the unsafe memory reference\n   */\n  function unsafeCopyTo(bytes29 memView, uint256 _newLoc) private view returns (bytes29 written) {\n    require(notNull(memView), \"TypedMemView/copyTo - Null pointer deref\");\n    require(isValid(memView), \"TypedMemView/copyTo - Invalid pointer deref\");\n    uint256 _len = len(memView);\n    uint256 _oldLoc = loc(memView);\n\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _newLoc) {\n        revert(0x60, 0x20) // empty revert message\n      }\n\n      // use the identity precompile to copy\n      // guaranteed not to fail, so pop the success\n      pop(staticcall(gas(), 4, _oldLoc, _len, _newLoc, _len))\n    }\n\n    written = unsafeBuildUnchecked(typeOf(memView), _newLoc, _len);\n  }\n\n  /**\n   * @notice          Copies the referenced memory to a new loc in memory, returning a `bytes` pointing to\n   *                  the new memory\n   * @dev             Shortcuts if the pointers are identical, otherwise compares type and digest.\n   * @param memView   The view\n   * @return          ret - The view pointing to the new memory\n   */\n  function clone(bytes29 memView) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    uint256 _len = len(memView);\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n      ret := ptr\n    }\n    unchecked {\n      unsafeCopyTo(memView, ptr + 0x20);\n    }\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      mstore(0x40, add(add(ptr, _len), 0x20)) // write new unused pointer\n      mstore(ptr, _len) // write len of new array (in bytes)\n    }\n  }\n\n  /**\n   * @notice          Join the views in memory, return an unsafe reference to the memory.\n   * @dev             Super Dangerous direct memory access.\n   *\n   *                  This reference can be overwritten if anything else modifies memory (!!!).\n   *                  As such it MUST be consumed IMMEDIATELY.\n   *                  This function is private to prevent unsafe usage by callers.\n   * @param memViews  The views\n   * @return          unsafeView - The conjoined view pointing to the new memory\n   */\n  function unsafeJoin(bytes29[] memory memViews, uint256 _location) private view returns (bytes29 unsafeView) {\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      let ptr := mload(0x40)\n      // revert if we're writing in occupied memory\n      if gt(ptr, _location) {\n        revert(0x60, 0x20) // empty revert message\n      }\n    }\n\n    uint256 _offset = 0;\n    for (uint256 i = 0; i < memViews.length; i++) {\n      bytes29 memView = memViews[i];\n      unchecked {\n        unsafeCopyTo(memView, _location + _offset);\n        _offset += len(memView);\n      }\n    }\n    unsafeView = unsafeBuildUnchecked(0, _location, _offset);\n  }\n\n  /**\n   * @notice          Produce the keccak256 digest of the concatenated contents of multiple views.\n   * @param memViews  The views\n   * @return          bytes32 - The keccak256 digest\n   */\n  function joinKeccak(bytes29[] memory memViews) internal view returns (bytes32) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n    return keccak(unsafeJoin(memViews, ptr));\n  }\n\n  /**\n   * @notice          Produce the sha256 digest of the concatenated contents of multiple views.\n   * @param memViews  The views\n   * @return          bytes32 - The sha256 digest\n   */\n  function joinSha2(bytes29[] memory memViews) internal view returns (bytes32) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n    return sha2(unsafeJoin(memViews, ptr));\n  }\n\n  /**\n   * @notice          copies all views, joins them into a new bytearray.\n   * @param memViews  The views\n   * @return          ret - The new byte array\n   */\n  function join(bytes29[] memory memViews) internal view returns (bytes memory ret) {\n    uint256 ptr;\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      ptr := mload(0x40) // load unused memory pointer\n    }\n\n    bytes29 _newView;\n    unchecked {\n      _newView = unsafeJoin(memViews, ptr + 0x20);\n    }\n    uint256 _written = len(_newView);\n    uint256 _footprint = footprint(_newView);\n\n    assembly {\n      // solhint-disable-previous-line no-inline-assembly\n      // store the legnth\n      mstore(ptr, _written)\n      // new pointer is old + 0x20 + the footprint of the body\n      mstore(0x40, add(add(ptr, _footprint), 0x20))\n      ret := ptr\n    }\n  }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@connext/nxtp-contracts/contracts/nomad-core/interfaces/IMessageRecipient.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.6.11;\n\ninterface IMessageRecipient {\n  function handle(\n    uint32 _origin,\n    uint32 _nonce,\n    bytes32 _sender,\n    bytes memory _message\n  ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}