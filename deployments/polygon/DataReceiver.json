{
  "address": "0x4B11b6BEF9480d62b471a9a91a52C893143Bad19",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_governor",
          "type": "address"
        },
        {
          "internalType": "contract IOracleFactory",
          "name": "_oracleFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "InvalidAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidAmount",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LengthMismatch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ObservationsNotWritable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyGovernor",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyPendingGovernor",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnallowedAdapter",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ZeroAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract IBridgeReceiverAdapter",
          "name": "_adapter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "_isAllowed",
          "type": "bool"
        }
      ],
      "name": "AdapterWhitelisted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_poolSalt",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint24",
          "name": "_poolNonce",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_receiverAdapter",
          "type": "address"
        }
      ],
      "name": "ObservationsAdded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "bytes32",
          "name": "_poolSalt",
          "type": "bytes32"
        },
        {
          "indexed": false,
          "internalType": "uint24",
          "name": "_poolNonce",
          "type": "uint24"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_receiverAdapter",
          "type": "address"
        }
      ],
      "name": "ObservationsCached",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newGovernor",
          "type": "address"
        }
      ],
      "name": "PendingGovernorAccepted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_governor",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "_pendingGovernor",
          "type": "address"
        }
      ],
      "name": "PendingGovernorSet",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptPendingGovernor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "blockTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "int24",
              "name": "tick",
              "type": "int24"
            }
          ],
          "internalType": "struct IOracleSidechain.ObservationData[]",
          "name": "_observationsData",
          "type": "tuple[]"
        },
        {
          "internalType": "bytes32",
          "name": "_poolSalt",
          "type": "bytes32"
        },
        {
          "internalType": "uint24",
          "name": "_poolNonce",
          "type": "uint24"
        }
      ],
      "name": "addObservations",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "name": "deployedOracles",
      "outputs": [
        {
          "internalType": "contract IOracleSidechain",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governor",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracleFactory",
      "outputs": [
        {
          "internalType": "contract IOracleFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingGovernor",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_pendingGovernor",
          "type": "address"
        }
      ],
      "name": "setPendingGovernor",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBridgeReceiverAdapter",
          "name": "_receiverAdapter",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_isWhitelisted",
          "type": "bool"
        }
      ],
      "name": "whitelistAdapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBridgeReceiverAdapter[]",
          "name": "_receiverAdapters",
          "type": "address[]"
        },
        {
          "internalType": "bool[]",
          "name": "_isWhitelisted",
          "type": "bool[]"
        }
      ],
      "name": "whitelistAdapters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBridgeReceiverAdapter",
          "name": "",
          "type": "address"
        }
      ],
      "name": "whitelistedAdapters",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xd56881b273081e5b436289093e54bd3f1acfc96aaf90fc739077e33d0a68ac8d",
  "receipt": {
    "to": null,
    "from": "0xa6DBFF53DD8F89f0bf4f6800BFDFfE099875bd9d",
    "contractAddress": "0x4B11b6BEF9480d62b471a9a91a52C893143Bad19",
    "transactionIndex": 32,
    "gasUsed": "881190",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000004000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000800000000000000001000000008000000000000000000000140000000000000000020000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x88a71fa92bc096640c20eb4eb85274e5aa6442317c62ba75c4352549b9dd9155",
    "transactionHash": "0xd56881b273081e5b436289093e54bd3f1acfc96aaf90fc739077e33d0a68ac8d",
    "logs": [
      {
        "transactionIndex": 32,
        "blockNumber": 60829155,
        "transactionHash": "0xd56881b273081e5b436289093e54bd3f1acfc96aaf90fc739077e33d0a68ac8d",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000a6dbff53dd8f89f0bf4f6800bfdffe099875bd9d",
          "0x00000000000000000000000067b94473d81d0cd00849d563c94d0432ac988b49"
        ],
        "data": "0x000000000000000000000000000000000000000000000000005deb210bd615da0000000000000000000000000000000000000000000000004dae3786e9fbeca9000000000000000000000000000000000000000000001522667c5a277ec975e20000000000000000000000000000000000000000000000004d504c65de25d6cf00000000000000000000000000000000000000000000152266da45488a9f8bbc",
        "logIndex": 456,
        "blockHash": "0x88a71fa92bc096640c20eb4eb85274e5aa6442317c62ba75c4352549b9dd9155"
      }
    ],
    "blockNumber": 60829155,
    "cumulativeGasUsed": "15483227",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0xa6DBFF53DD8F89f0bf4f6800BFDFfE099875bd9d",
    "0xa32f6603F9466eF0190CAc36759E41B40653471A"
  ],
  "numDeployments": 1,
  "solcInputHash": "92b61157bb7b7ae620a9f78d2e6fe053",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"internalType\":\"contract IOracleFactory\",\"name\":\"_oracleFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"InvalidAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidAmount\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ObservationsNotWritable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingGovernor\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallowedAdapter\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ZeroAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IBridgeReceiverAdapter\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"AdapterWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_poolSalt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"_poolNonce\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiverAdapter\",\"type\":\"address\"}],\"name\":\"ObservationsAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"bytes32\",\"name\":\"_poolSalt\",\"type\":\"bytes32\"},{\"indexed\":false,\"internalType\":\"uint24\",\"name\":\"_poolNonce\",\"type\":\"uint24\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_receiverAdapter\",\"type\":\"address\"}],\"name\":\"ObservationsCached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newGovernor\",\"type\":\"address\"}],\"name\":\"PendingGovernorAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_governor\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pendingGovernor\",\"type\":\"address\"}],\"name\":\"PendingGovernorSet\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"internalType\":\"struct IOracleSidechain.ObservationData[]\",\"name\":\"_observationsData\",\"type\":\"tuple[]\"},{\"internalType\":\"bytes32\",\"name\":\"_poolSalt\",\"type\":\"bytes32\"},{\"internalType\":\"uint24\",\"name\":\"_poolNonce\",\"type\":\"uint24\"}],\"name\":\"addObservations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"deployedOracles\",\"outputs\":[{\"internalType\":\"contract IOracleSidechain\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleFactory\",\"outputs\":[{\"internalType\":\"contract IOracleFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernor\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_pendingGovernor\",\"type\":\"address\"}],\"name\":\"setPendingGovernor\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridgeReceiverAdapter\",\"name\":\"_receiverAdapter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridgeReceiverAdapter[]\",\"name\":\"_receiverAdapters\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isWhitelisted\",\"type\":\"bool[]\"}],\"name\":\"whitelistAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridgeReceiverAdapter\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAdapters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"addObservations((uint32,int24)[],bytes32,uint24)\":{\"params\":{\"_observationsData\":\"Array of tuples containing the dataset\",\"_poolNonce\":\"Nonce of the observation broadcast\",\"_poolSalt\":\"Identifier of the pool to fetch\"}},\"setPendingGovernor(address)\":{\"params\":{\"_pendingGovernor\":\"Address of the proposed new governor\"}},\"whitelistAdapter(address,bool)\":{\"params\":{\"_isWhitelisted\":\"New whitelisting status\",\"_receiverAdapter\":\"Address of the adapter\"}},\"whitelistAdapters(address[],bool[])\":{\"params\":{\"_isWhitelisted\":\"Array of whitelisting status for each address\",\"_receiverAdapters\":\"Array of addresses of the adapter\"}}},\"stateVariables\":{\"deployedOracles\":{\"params\":{\"_poolSalt\":\"The identifier of the oracle\"},\"return\":\"The address of the correspondant Oracle\",\"returns\":{\"_0\":\"The address of the correspondant Oracle\"}},\"oracleFactory\":{\"return\":\"The address of the OracleFactory\",\"returns\":{\"_0\":\"The address of the OracleFactory\"}},\"whitelistedAdapters\":{\"params\":{\"_adapter\":\"Address of the bridge adapter to consult\"},\"return\":\"Whether a bridge adapter is whitelisted\",\"returns\":{\"_0\":\"Whether a bridge adapter is whitelisted\"}}},\"title\":\"The DataReceiver contract\",\"version\":1},\"userdoc\":{\"errors\":{\"InvalidAddress()\":[{\"notice\":\"Thrown if an address is invalid\"}],\"InvalidAmount()\":[{\"notice\":\"Thrown if an amount is invalid\"}],\"LengthMismatch()\":[{\"notice\":\"Thrown if the lengths of a set of lists mismatch\"}],\"ObservationsNotWritable()\":[{\"notice\":\"Thrown when the broadcast nonce is incorrect\"}],\"OnlyGovernor()\":[{\"notice\":\"Thrown if a non-governor user tries to call a OnlyGovernor function\"}],\"OnlyPendingGovernor()\":[{\"notice\":\"Thrown if a non-pending-governor user tries to call a OnlyPendingGovernor function\"}],\"UnallowedAdapter()\":[{\"notice\":\"Thrown when a not-whitelisted adapter triggers an update\"}],\"ZeroAddress()\":[{\"notice\":\"Thrown if an address is the zero address\"}],\"ZeroAmount()\":[{\"notice\":\"Thrown if an amount is zero\"}]},\"events\":{\"AdapterWhitelisted(address,bool)\":{\"notice\":\"Emitted when a new adapter whitelisting rule is set\"},\"ObservationsAdded(bytes32,uint24,address)\":{\"notice\":\"Emitted when a broadcast observation is succesfully processed\"},\"ObservationsCached(bytes32,uint24,address)\":{\"notice\":\"Emitted when a broadcast observation is cached for later processing\"},\"PendingGovernorAccepted(address)\":{\"notice\":\"Emitted when a new governor is set\"},\"PendingGovernorSet(address,address)\":{\"notice\":\"Emitted when a new pending governor is set\"}},\"kind\":\"user\",\"methods\":{\"acceptPendingGovernor()\":{\"notice\":\"Allows a proposed governor to accept the governance\"},\"addObservations((uint32,int24)[],bytes32,uint24)\":{\"notice\":\"Allows whitelisted bridge adapters to push a broadcast\"},\"deployedOracles(bytes32)\":{\"notice\":\"Tracks already deployed oracles\"},\"setPendingGovernor(address)\":{\"notice\":\"Allows a governor to propose a new governor\"},\"whitelistAdapter(address,bool)\":{\"notice\":\"Allows governance to set an adapter whitelisted state\"},\"whitelistAdapters(address[],bool[])\":{\"notice\":\"Allows governance to batch set adapters whitelisted state\"},\"whitelistedAdapters(address)\":{\"notice\":\"Tracks the whitelisting of bridge adapters\"}},\"notice\":\"Handles reception of broadcast data and delivers it to correspondant oracle\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/contracts/DataReceiver.sol\":\"DataReceiver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@defi-wonderland/solidity-utils/solidity/contracts/Governable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IGovernable} from '../interfaces/IGovernable.sol';\\n\\n/// @title Governable contract\\n/// @notice Manages the governor role\\nabstract contract Governable is IGovernable {\\n    /// @inheritdoc IGovernable\\n    address public governor;\\n\\n    /// @inheritdoc IGovernable\\n    address public pendingGovernor;\\n\\n    constructor(address _governor) {\\n        if (_governor == address(0)) revert ZeroAddress();\\n        governor = _governor;\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\\n        _setPendingGovernor(_pendingGovernor);\\n    }\\n\\n    /// @inheritdoc IGovernable\\n    function acceptPendingGovernor() external onlyPendingGovernor {\\n        _acceptPendingGovernor();\\n    }\\n\\n    function _setPendingGovernor(address _pendingGovernor) internal {\\n        if (_pendingGovernor == address(0)) revert ZeroAddress();\\n        pendingGovernor = _pendingGovernor;\\n        emit PendingGovernorSet(governor, _pendingGovernor);\\n    }\\n\\n    function _acceptPendingGovernor() internal {\\n        governor = pendingGovernor;\\n        delete pendingGovernor;\\n        emit PendingGovernorAccepted(governor);\\n    }\\n\\n    /// @notice Functions with this modifier can only be called by governor\\n    modifier onlyGovernor() {\\n        if (msg.sender != governor) revert OnlyGovernor();\\n        _;\\n    }\\n\\n    /// @notice Functions with this modifier can only be called by pendingGovernor\\n    modifier onlyPendingGovernor() {\\n        if (msg.sender != pendingGovernor) revert OnlyPendingGovernor();\\n        _;\\n    }\\n}\\n\",\"keccak256\":\"0x3f11408cfcb015a99dc417e075c8ebc39b796fc2adc3e81b036487e4486881b3\",\"license\":\"MIT\"},\"@defi-wonderland/solidity-utils/solidity/interfaces/IBaseErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\ninterface IBaseErrors {\\n    /// @notice Thrown if an address is invalid\\n    error InvalidAddress();\\n\\n    /// @notice Thrown if an amount is invalid\\n    error InvalidAmount();\\n\\n    /// @notice Thrown if the lengths of a set of lists mismatch\\n    error LengthMismatch();\\n\\n    /// @notice Thrown if an address is the zero address\\n    error ZeroAddress();\\n\\n    /// @notice Thrown if an amount is zero\\n    error ZeroAmount();\\n}\\n\",\"keccak256\":\"0xec09b9d248b6fbf6343dee41d6978abdc15d4c8df5ed7721e8df79e8b1a558cf\",\"license\":\"MIT\"},\"@defi-wonderland/solidity-utils/solidity/interfaces/IGovernable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IBaseErrors} from './IBaseErrors.sol';\\n\\n/// @title Governable interface\\ninterface IGovernable is IBaseErrors {\\n    // STATE VARIABLES\\n\\n    /// @return _governor Address of the current governor\\n    function governor() external view returns (address _governor);\\n\\n    /// @return _pendingGovernor Address of the current pending governor\\n    function pendingGovernor() external view returns (address _pendingGovernor);\\n\\n    // EVENTS\\n\\n    /// @notice Emitted when a new pending governor is set\\n    /// @param _governor Address of the current governor\\n    /// @param _pendingGovernor Address of the proposed next governor\\n    event PendingGovernorSet(address _governor, address _pendingGovernor);\\n\\n    /// @notice Emitted when a new governor is set\\n    /// @param _newGovernor Address of the new governor\\n    event PendingGovernorAccepted(address _newGovernor);\\n\\n    // ERRORS\\n\\n    /// @notice Thrown if a non-governor user tries to call a OnlyGovernor function\\n    error OnlyGovernor();\\n\\n    /// @notice Thrown if a non-pending-governor user tries to call a OnlyPendingGovernor function\\n    error OnlyPendingGovernor();\\n\\n    // FUNCTIONS\\n\\n    /// @notice Allows a governor to propose a new governor\\n    /// @param _pendingGovernor Address of the proposed new governor\\n    function setPendingGovernor(address _pendingGovernor) external;\\n\\n    /// @notice Allows a proposed governor to accept the governance\\n    function acceptPendingGovernor() external;\\n}\\n\",\"keccak256\":\"0x40b94706a00d2c092f620807ba84bdd0c5ed8cfa60140c924edc850427e0af13\",\"license\":\"MIT\"},\"@uniswap/v3-core/contracts/libraries/Oracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @title Oracle\\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\\n/// @dev Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array\\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\\n/// Observations are overwritten when the full length of the oracle array is populated.\\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\\nlibrary Oracle {\\n    error I();\\n    error OLD();\\n\\n    struct Observation {\\n        // the block timestamp of the observation\\n        uint32 blockTimestamp;\\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\\n        int56 tickCumulative;\\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\\n        uint160 secondsPerLiquidityCumulativeX128;\\n        // whether or not the observation is initialized\\n        bool initialized;\\n    }\\n\\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\\n    /// @param last The specified observation to be transformed\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param tick The active tick at the time of the new observation\\n    /// @param liquidity The total in-range liquidity at the time of the new observation\\n    /// @return Observation The newly populated observation\\n    function transform(\\n        Observation memory last,\\n        uint32 blockTimestamp,\\n        int24 tick,\\n        uint128 liquidity\\n    ) private pure returns (Observation memory) {\\n        unchecked {\\n            uint32 delta = blockTimestamp - last.blockTimestamp;\\n            return\\n                Observation({\\n                    blockTimestamp: blockTimestamp,\\n                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\\n                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\\n                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\\n                    initialized: true\\n                });\\n        }\\n    }\\n\\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\\n    /// @param self The stored oracle array\\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\\n    /// @return cardinality The number of populated elements in the oracle array\\n    /// @return cardinalityNext The new length of the oracle array, independent of population\\n    function initialize(Observation[65535] storage self, uint32 time)\\n        internal\\n        returns (uint16 cardinality, uint16 cardinalityNext)\\n    {\\n        self[0] = Observation({\\n            blockTimestamp: time,\\n            tickCumulative: 0,\\n            secondsPerLiquidityCumulativeX128: 0,\\n            initialized: true\\n        });\\n        return (1, 1);\\n    }\\n\\n    /// @notice Writes an oracle observation to the array\\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\\n    /// @param self The stored oracle array\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param tick The active tick at the time of the new observation\\n    /// @param liquidity The total in-range liquidity at the time of the new observation\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @param cardinalityNext The new length of the oracle array, independent of population\\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\\n    /// @return cardinalityUpdated The new cardinality of the oracle array\\n    function write(\\n        Observation[65535] storage self,\\n        uint16 index,\\n        uint32 blockTimestamp,\\n        int24 tick,\\n        uint128 liquidity,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\\n        unchecked {\\n            Observation memory last = self[index];\\n\\n            // early return if we've already written an observation this block\\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\\n\\n            // if the conditions are right, we can bump the cardinality\\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\\n                cardinalityUpdated = cardinalityNext;\\n            } else {\\n                cardinalityUpdated = cardinality;\\n            }\\n\\n            indexUpdated = (index + 1) % cardinalityUpdated;\\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\\n        }\\n    }\\n\\n    /// @notice Prepares the oracle array to store up to `next` observations\\n    /// @param self The stored oracle array\\n    /// @param current The current next cardinality of the oracle array\\n    /// @param next The proposed next cardinality which will be populated in the oracle array\\n    /// @return next The next cardinality which will be populated in the oracle array\\n    function grow(\\n        Observation[65535] storage self,\\n        uint16 current,\\n        uint16 next\\n    ) internal returns (uint16) {\\n        unchecked {\\n            if (current <= 0) revert I();\\n            // no-op if the passed next value isn't greater than the current next value\\n            if (next <= current) return current;\\n            // store in each slot to prevent fresh SSTOREs in swaps\\n            // this data will not be used because the initialized boolean is still false\\n            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\\n            return next;\\n        }\\n    }\\n\\n    /// @notice comparator for 32-bit timestamps\\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\\n    /// @param time A timestamp truncated to 32 bits\\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\\n    /// @param b From which to determine the relative position of `time`\\n    /// @return Whether `a` is chronologically <= `b`\\n    function lte(\\n        uint32 time,\\n        uint32 a,\\n        uint32 b\\n    ) private pure returns (bool) {\\n        unchecked {\\n            // if there hasn't been overflow, no need to adjust\\n            if (a <= time && b <= time) return a <= b;\\n\\n            uint256 aAdjusted = a > time ? a : a + 2**32;\\n            uint256 bAdjusted = b > time ? b : b + 2**32;\\n\\n            return aAdjusted <= bAdjusted;\\n        }\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\\n    /// The result may be the same observation, or adjacent observations.\\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation recorded before, or at, the target\\n    /// @return atOrAfter The observation recorded at, or after, the target\\n    function binarySearch(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 target,\\n        uint16 index,\\n        uint16 cardinality\\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        unchecked {\\n            uint256 l = (index + 1) % cardinality; // oldest observation\\n            uint256 r = l + cardinality - 1; // newest observation\\n            uint256 i;\\n            while (true) {\\n                i = (l + r) / 2;\\n\\n                beforeOrAt = self[i % cardinality];\\n\\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\\n                if (!beforeOrAt.initialized) {\\n                    l = i + 1;\\n                    continue;\\n                }\\n\\n                atOrAfter = self[(i + 1) % cardinality];\\n\\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\\n\\n                // check if we've found the answer!\\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\\n\\n                if (!targetAtOrAfter) r = i - 1;\\n                else l = i + 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\\n    /// @dev Assumes there is at least 1 initialized observation.\\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param tick The active tick at the time of the returned or simulated observation\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The total pool liquidity at the time of the call\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\\n    function getSurroundingObservations(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 target,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        unchecked {\\n            // optimistically set before to the newest observation\\n            beforeOrAt = self[index];\\n\\n            // if the target is chronologically at or after the newest observation, we can early return\\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\\n                if (beforeOrAt.blockTimestamp == target) {\\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\\n                    return (beforeOrAt, atOrAfter);\\n                } else {\\n                    // otherwise, we need to transform\\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\\n                }\\n            }\\n\\n            // now, set before to the oldest observation\\n            beforeOrAt = self[(index + 1) % cardinality];\\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\\n\\n            // ensure that the target is chronologically at or after the oldest observation\\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\\n\\n            // if we've reached this point, we have to binary search\\n            return binarySearch(self, time, target, index, cardinality);\\n        }\\n    }\\n\\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\\n    /// at exactly the timestamp between the two observations.\\n    /// @param self The stored oracle array\\n    /// @param time The current block timestamp\\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\\n    /// @param tick The current tick\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The current in-range pool liquidity\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\\n    function observeSingle(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 secondsAgo,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\\n        unchecked {\\n            if (secondsAgo == 0) {\\n                Observation memory last = self[index];\\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\\n            }\\n\\n            uint32 target = time - secondsAgo;\\n\\n            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\\n                self,\\n                time,\\n                target,\\n                tick,\\n                index,\\n                liquidity,\\n                cardinality\\n            );\\n\\n            if (target == beforeOrAt.blockTimestamp) {\\n                // we're at the left boundary\\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\\n            } else if (target == atOrAfter.blockTimestamp) {\\n                // we're at the right boundary\\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\\n            } else {\\n                // we're in the middle\\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\\n                return (\\n                    beforeOrAt.tickCumulative +\\n                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\\n                        int56(uint56(targetDelta)),\\n                    beforeOrAt.secondsPerLiquidityCumulativeX128 +\\n                        uint160(\\n                            (uint256(\\n                                atOrAfter.secondsPerLiquidityCumulativeX128 -\\n                                    beforeOrAt.secondsPerLiquidityCumulativeX128\\n                            ) * targetDelta) / observationTimeDelta\\n                        )\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\n    /// @dev Reverts if `secondsAgos` > oldest observation\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\\n    /// @param tick The current tick\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The current in-range pool liquidity\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\\n    function observe(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32[] memory secondsAgos,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\\n        unchecked {\\n            if (cardinality <= 0) revert I();\\n\\n            tickCumulatives = new int56[](secondsAgos.length);\\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\\n                    self,\\n                    time,\\n                    secondsAgos[i],\\n                    tick,\\n                    index,\\n                    liquidity,\\n                    cardinality\\n                );\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa25b18af947c36b9add9e229c361beb6aba176fb435d7a24e6dc723cbc187442\",\"license\":\"BUSL-1.1\"},\"@uniswap/v3-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity ^0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    error T();\\n    error R();\\n\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        unchecked {\\n            uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n            if (absTick > uint256(int256(MAX_TICK))) revert T();\\n\\n            uint256 ratio = absTick & 0x1 != 0\\n                ? 0xfffcb933bd6fad37aa2d162d1a594001\\n                : 0x100000000000000000000000000000000;\\n            if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n            if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n            if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n            if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n            if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n            if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n            if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n            if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n            if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n            if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n            if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n            if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n            if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n            if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n            if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n            if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n            if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n            if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n            if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n            if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n            // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n            // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n            // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n            sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n        }\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        unchecked {\\n            // second inequality must be < because the price can never reach the price at the max tick\\n            if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\\n            uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n            uint256 r = ratio;\\n            uint256 msb = 0;\\n\\n            assembly {\\n                let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(5, gt(r, 0xFFFFFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(4, gt(r, 0xFFFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(3, gt(r, 0xFF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(2, gt(r, 0xF))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := shl(1, gt(r, 0x3))\\n                msb := or(msb, f)\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                let f := gt(r, 0x1)\\n                msb := or(msb, f)\\n            }\\n\\n            if (msb >= 128) r = ratio >> (msb - 127);\\n            else r = ratio << (127 - msb);\\n\\n            int256 log_2 = (int256(msb) - 128) << 64;\\n\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(63, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(62, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(61, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(60, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(59, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(58, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(57, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(56, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(55, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(54, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(53, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(52, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(51, f))\\n                r := shr(f, r)\\n            }\\n            assembly {\\n                r := shr(127, mul(r, r))\\n                let f := shr(128, r)\\n                log_2 := or(log_2, shl(50, f))\\n            }\\n\\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n            int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n            int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n            tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x5c57de03a91cc2ec8939865dbbcb0197bb6c353b711075eefd8e0fca5e102129\",\"license\":\"GPL-2.0-or-later\"},\"solidity/contracts/DataReceiver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {Governable} from '@defi-wonderland/solidity-utils/solidity/contracts/Governable.sol';\\nimport {OracleSidechain} from './OracleSidechain.sol';\\nimport {IDataReceiver, IOracleFactory, IOracleSidechain, IBridgeReceiverAdapter} from '../interfaces/IDataReceiver.sol';\\n\\n/// @title The DataReceiver contract\\n/// @notice Handles reception of broadcast data and delivers it to correspondant oracle\\ncontract DataReceiver is IDataReceiver, Governable {\\n  /// @inheritdoc IDataReceiver\\n  IOracleFactory public immutable oracleFactory;\\n\\n  /// @inheritdoc IDataReceiver\\n  mapping(bytes32 => IOracleSidechain) public deployedOracles;\\n\\n  /// @inheritdoc IDataReceiver\\n  mapping(IBridgeReceiverAdapter => bool) public whitelistedAdapters;\\n\\n  mapping(bytes32 => mapping(uint24 => IOracleSidechain.ObservationData[])) internal _cachedObservations;\\n\\n  constructor(address _governor, IOracleFactory _oracleFactory) Governable(_governor) {\\n    if (address(_oracleFactory) == address(0)) revert ZeroAddress();\\n    oracleFactory = _oracleFactory;\\n  }\\n\\n  function addObservations(\\n    IOracleSidechain.ObservationData[] memory _observationsData,\\n    bytes32 _poolSalt,\\n    uint24 _poolNonce\\n  ) external onlyWhitelistedAdapters {\\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\\n  }\\n\\n  function _addObservations(\\n    IOracleSidechain.ObservationData[] memory _observationsData,\\n    bytes32 _poolSalt,\\n    uint24 _poolNonce\\n  ) internal {\\n    // Read, store or deploy oracle given poolSalt\\n    IOracleSidechain _oracle = deployedOracles[_poolSalt];\\n    if (address(_oracle) == address(0)) {\\n      _oracle = oracleFactory.getPool(_poolSalt);\\n      if (address(_oracle) == address(0)) {\\n        _oracle = oracleFactory.deployOracle(_poolSalt, _poolNonce);\\n      }\\n      deployedOracles[_poolSalt] = _oracle;\\n    }\\n    // Try to write observations data into oracle\\n    if (_oracle.write(_observationsData, _poolNonce)) {\\n      emit ObservationsAdded(_poolSalt, _poolNonce, msg.sender);\\n    } else {\\n      // Query pool's current nonce\\n      uint24 _currentNonce = _oracle.poolNonce();\\n      // Discard old observations (already written in the oracle)\\n      // NOTE: if _currentNonce == _poolNonce it shouldn't reach this else block\\n      if (_currentNonce > _poolNonce) revert ObservationsNotWritable();\\n      // Store not-added observations to cachedObservations mapping\\n      // NOTE: memory to storage is not supported\\n      // cachedObservations[_poolSalt][_poolNonce] = _observationsData;\\n      for (uint256 _i; _i < _observationsData.length; ++_i) {\\n        _cachedObservations[_poolSalt][_poolNonce].push(_observationsData[_i]);\\n      }\\n      emit ObservationsCached(_poolSalt, _poolNonce, msg.sender);\\n      while (_currentNonce <= _poolNonce) {\\n        // Try backfilling pending observations (from current to {sent|first empty} nonce)\\n        _observationsData = _cachedObservations[_poolSalt][_currentNonce];\\n        // If the struct is not empty, write it into the oracle\\n        if (_observationsData.length > 0) {\\n          // Since observation nonce == oracle nonce, we can safely write the observations\\n          _oracle.write(_observationsData, _currentNonce);\\n          emit ObservationsAdded(_poolSalt, _currentNonce, msg.sender);\\n          // Clear out the written observations\\n          delete _cachedObservations[_poolSalt][_currentNonce];\\n          _currentNonce++;\\n        } else {\\n          // When an empty nonce is found, break the loop\\n          break;\\n        }\\n      }\\n    }\\n  }\\n\\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external onlyGovernor {\\n    _whitelistAdapter(_receiverAdapter, _isWhitelisted);\\n  }\\n\\n  /// @inheritdoc IDataReceiver\\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external onlyGovernor {\\n    uint256 _receiverAdapterLength = _receiverAdapters.length;\\n    if (_receiverAdapterLength != _isWhitelisted.length) revert LengthMismatch();\\n    unchecked {\\n      for (uint256 _i; _i < _receiverAdapterLength; ++_i) {\\n        _whitelistAdapter(_receiverAdapters[_i], _isWhitelisted[_i]);\\n      }\\n    }\\n  }\\n\\n  function _whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) internal {\\n    whitelistedAdapters[_receiverAdapter] = _isWhitelisted;\\n    emit AdapterWhitelisted(_receiverAdapter, _isWhitelisted);\\n  }\\n\\n  modifier onlyWhitelistedAdapters() {\\n    if (!whitelistedAdapters[IBridgeReceiverAdapter(msg.sender)]) revert UnallowedAdapter();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x7deb2aab640dc0ace6fdc7bb54a27f1a31c04a17754bb725d830b06075418d68\",\"license\":\"MIT\"},\"solidity/contracts/OracleSidechain.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n/*\\n\\nCoded for The Keep3r Network with \\u2665 by\\n\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2557\\u2591\\u2591\\u2591\\u2588\\u2588\\u2557\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2588\\u2557\\u2591\\u2591\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2557\\u2591\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2588\\u2557\\u2591\\u2591\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\n\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255d\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255d\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2557\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u2550\\u2550\\u2550\\u2550\\u255d\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\n\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2591\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u255a\\u2588\\u2588\\u2557\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u255d\\u2591\\u2591\\u2588\\u2588\\u2554\\u2550\\u2550\\u255d\\u2591\\u2591\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2588\\u2588\\u2554\\u2550\\u2588\\u2588\\u2588\\u2588\\u2551\\u2591\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2554\\u2550\\u2550\\u255d\\u2591\\u2591\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2554\\u2550\\u2550\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u255a\\u2588\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\n\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2591\\u2591\\u2588\\u2588\\u2551\\u2591\\u2591\\u2591\\u2591\\u255a\\u2588\\u2588\\u2554\\u255d\\u2591\\u255a\\u2588\\u2588\\u2554\\u255d\\u2591\\u255a\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2551\\u2591\\u255a\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2557\\u2588\\u2588\\u2551\\u2591\\u2591\\u2588\\u2588\\u2551\\u2588\\u2588\\u2551\\u2591\\u255a\\u2588\\u2588\\u2588\\u2551\\u2588\\u2588\\u2588\\u2588\\u2588\\u2588\\u2554\\u255d\\n\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u2591\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u255a\\u2550\\u255d\\u2591\\u2591\\u2591\\u2591\\u2591\\u255a\\u2550\\u255d\\u2591\\u2591\\u2591\\u2591\\u2591\\u255a\\u2550\\u255d\\u2591\\u2591\\u2591\\u255a\\u2550\\u255d\\u2591\\u2591\\u2591\\u255a\\u2550\\u2550\\u2550\\u2550\\u255d\\u2591\\u255a\\u2550\\u255d\\u2591\\u2591\\u255a\\u2550\\u2550\\u255d\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u2591\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u255a\\u2550\\u255d\\u2591\\u2591\\u255a\\u2550\\u255d\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u255a\\u2550\\u255d\\u2591\\u2591\\u255a\\u2550\\u255d\\u255a\\u2550\\u255d\\u2591\\u2591\\u255a\\u2550\\u2550\\u255d\\u255a\\u2550\\u2550\\u2550\\u2550\\u2550\\u255d\\u2591\\n\\nhttps://defi.sucks\\n\\n*/\\n\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IOracleSidechain, IOracleFactory} from '../interfaces/IOracleSidechain.sol';\\nimport {Oracle} from '@uniswap/v3-core/contracts/libraries/Oracle.sol';\\nimport {TickMath} from '@uniswap/v3-core/contracts/libraries/TickMath.sol';\\n\\n/// @title The SidechainOracle contract\\n/// @notice Computes and stores on-chain price data from Mainnet\\ncontract OracleSidechain is IOracleSidechain {\\n  using Oracle for Oracle.Observation[65535];\\n\\n  /// @inheritdoc IOracleSidechain\\n  IOracleFactory public immutable factory;\\n\\n  struct Slot0 {\\n    // the current price\\n    uint160 sqrtPriceX96;\\n    // the current tick\\n    int24 tick;\\n    // the most-recently updated index of the observations array\\n    uint16 observationIndex;\\n    // the current maximum number of observations that are being stored\\n    uint16 observationCardinality;\\n    // the next maximum number of observations to store, triggered in observations.write\\n    uint16 observationCardinalityNext;\\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\\n    // represented as an integer denominator (1/x)%\\n    uint8 feeProtocol;\\n    // whether the pool is locked\\n    bool unlocked;\\n  }\\n  /// @inheritdoc IOracleSidechain\\n  Slot0 public slot0;\\n\\n  /// @inheritdoc IOracleSidechain\\n  Oracle.Observation[65535] public observations;\\n\\n  /// @inheritdoc IOracleSidechain\\n  bytes32 public immutable poolSalt;\\n\\n  uint24 public poolNonce;\\n  /// @inheritdoc IOracleSidechain\\n  address public token0;\\n  /// @inheritdoc IOracleSidechain\\n  address public token1;\\n  /// @inheritdoc IOracleSidechain\\n  uint24 public fee;\\n\\n  /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\\n  function _getBlockTimestamp() internal view virtual returns (uint32) {\\n    return uint32(block.timestamp); // truncation is desired\\n  }\\n\\n  constructor() {\\n    factory = IOracleFactory(msg.sender);\\n    uint16 _cardinality;\\n    (poolSalt, poolNonce, _cardinality) = factory.oracleParameters();\\n\\n    slot0 = Slot0({\\n      sqrtPriceX96: 0,\\n      tick: 0,\\n      observationIndex: _cardinality - 1,\\n      observationCardinality: _cardinality,\\n      observationCardinalityNext: _cardinality,\\n      feeProtocol: 0,\\n      unlocked: true\\n    });\\n  }\\n\\n  /// @inheritdoc IOracleSidechain\\n  function initializePoolInfo(\\n    address _tokenA,\\n    address _tokenB,\\n    uint24 _fee\\n  ) external {\\n    if (!slot0.unlocked) revert AI();\\n\\n    (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\\n    if (poolSalt != keccak256(abi.encode(_token0, _token1, _fee))) revert InvalidPool();\\n\\n    token0 = _token0;\\n    token1 = _token1;\\n    fee = _fee;\\n    slot0.unlocked = false;\\n\\n    emit PoolInfoInitialized(poolSalt, _token0, _token1, _fee);\\n  }\\n\\n  /// @inheritdoc IOracleSidechain\\n  function observe(uint32[] calldata _secondsAgos)\\n    external\\n    view\\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s)\\n  {\\n    return observations.observe(_getBlockTimestamp(), _secondsAgos, slot0.tick, slot0.observationIndex, 0, slot0.observationCardinality);\\n  }\\n\\n  /// @inheritdoc IOracleSidechain\\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external onlyDataReceiver returns (bool _written) {\\n    if (_poolNonce != poolNonce) return false;\\n    poolNonce++;\\n\\n    uint256 _observationsDataLength = _observationsData.length;\\n    for (uint256 _i; _i < _observationsDataLength; ) {\\n      _write(_observationsData[_i]);\\n      unchecked {\\n        ++_i;\\n      }\\n    }\\n    slot0.sqrtPriceX96 = TickMath.getSqrtRatioAtTick(slot0.tick);\\n\\n    // emits UniV3 Swap event topic with minimal data\\n    emit Swap(address(0), address(0), 0, 0, slot0.sqrtPriceX96, 0, slot0.tick);\\n    return true;\\n  }\\n\\n  function increaseObservationCardinalityNext(uint16 _observationCardinalityNext) external onlyFactory {\\n    uint16 _observationCardinalityNextOld = slot0.observationCardinalityNext;\\n    if (_observationCardinalityNext <= _observationCardinalityNextOld) revert AI();\\n    slot0.observationCardinalityNext = _observationCardinalityNext;\\n    emit IncreaseObservationCardinalityNext(_observationCardinalityNextOld, _observationCardinalityNext);\\n  }\\n\\n  function _write(ObservationData memory _observationData) private {\\n    (uint16 _indexUpdated, uint16 _cardinalityUpdated) = observations.write(\\n      slot0.observationIndex,\\n      _observationData.blockTimestamp,\\n      slot0.tick,\\n      0,\\n      slot0.observationCardinality,\\n      slot0.observationCardinalityNext\\n    );\\n    (slot0.observationIndex, slot0.observationCardinality) = (_indexUpdated, _cardinalityUpdated);\\n    slot0.tick = _observationData.tick;\\n  }\\n\\n  modifier onlyDataReceiver() {\\n    if (msg.sender != address(factory.dataReceiver())) revert OnlyDataReceiver();\\n    _;\\n  }\\n\\n  modifier onlyFactory() {\\n    if (msg.sender != address(factory)) revert OnlyFactory();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x1b830dc6ad7405f2d533e1aa8eb079853edcdf301b396ac6b1d3c41573b62787\",\"license\":\"MIT\"},\"solidity/interfaces/IDataReceiver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IGovernable} from '@defi-wonderland/solidity-utils/solidity/interfaces/IGovernable.sol';\\nimport {IOracleFactory} from './IOracleFactory.sol';\\nimport {IOracleSidechain} from './IOracleSidechain.sol';\\nimport {IBridgeReceiverAdapter} from './bridges/IBridgeReceiverAdapter.sol';\\n\\ninterface IDataReceiver is IGovernable {\\n  // STATE VARIABLES\\n\\n  /// @return _oracleFactory The address of the OracleFactory\\n  function oracleFactory() external view returns (IOracleFactory _oracleFactory);\\n\\n  /// @notice Tracks already deployed oracles\\n  /// @param _poolSalt The identifier of the oracle\\n  /// @return _deployedOracle The address of the correspondant Oracle\\n  function deployedOracles(bytes32 _poolSalt) external view returns (IOracleSidechain _deployedOracle);\\n\\n  /// @notice Tracks the whitelisting of bridge adapters\\n  /// @param _adapter Address of the bridge adapter to consult\\n  /// @return _isAllowed Whether a bridge adapter is whitelisted\\n  function whitelistedAdapters(IBridgeReceiverAdapter _adapter) external view returns (bool _isAllowed);\\n\\n  // EVENTS\\n\\n  /// @notice Emitted when a broadcast observation is succesfully processed\\n  /// @param _poolSalt Identifier of the pool to fetch\\n  /// @return _poolNonce Nonce of the observation broadcast\\n  /// @return _receiverAdapter Handler of the broadcast\\n  event ObservationsAdded(bytes32 indexed _poolSalt, uint24 _poolNonce, address _receiverAdapter);\\n\\n  /// @notice Emitted when a broadcast observation is cached for later processing\\n  /// @param _poolSalt Identifier of the pool to fetch\\n  /// @return _poolNonce Nonce of the observation broadcast\\n  /// @return _receiverAdapter Handler of the broadcast\\n  event ObservationsCached(bytes32 indexed _poolSalt, uint24 _poolNonce, address _receiverAdapter);\\n\\n  /// @notice Emitted when a new adapter whitelisting rule is set\\n  /// @param _adapter Address of the adapter\\n  /// @param _isAllowed New whitelisting status\\n  event AdapterWhitelisted(IBridgeReceiverAdapter _adapter, bool _isAllowed);\\n\\n  // ERRORS\\n\\n  /// @notice Thrown when the broadcast nonce is incorrect\\n  error ObservationsNotWritable();\\n\\n  /// @notice Thrown when a not-whitelisted adapter triggers an update\\n  error UnallowedAdapter();\\n\\n  // FUNCTIONS\\n\\n  /// @notice Allows whitelisted bridge adapters to push a broadcast\\n  /// @param _observationsData Array of tuples containing the dataset\\n  /// @param _poolSalt Identifier of the pool to fetch\\n  /// @param _poolNonce Nonce of the observation broadcast\\n  function addObservations(\\n    IOracleSidechain.ObservationData[] memory _observationsData,\\n    bytes32 _poolSalt,\\n    uint24 _poolNonce\\n  ) external;\\n\\n  /// @notice Allows governance to set an adapter whitelisted state\\n  /// @param _receiverAdapter Address of the adapter\\n  /// @param _isWhitelisted New whitelisting status\\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external;\\n\\n  /// @notice Allows governance to batch set adapters whitelisted state\\n  /// @param _receiverAdapters Array of addresses of the adapter\\n  /// @param _isWhitelisted Array of whitelisting status for each address\\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external;\\n}\\n\",\"keccak256\":\"0x0d0e8404bc039a5fe8574b2ffd53489946fca020f72929caeced68e66f86e768\",\"license\":\"MIT\"},\"solidity/interfaces/IOracleFactory.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IGovernable} from '@defi-wonderland/solidity-utils/solidity/interfaces/IGovernable.sol';\\nimport {IOracleSidechain} from './IOracleSidechain.sol';\\nimport {IDataReceiver} from './IDataReceiver.sol';\\n\\ninterface IOracleFactory is IGovernable {\\n  // STRUCTS\\n\\n  struct OracleParameters {\\n    bytes32 poolSalt; // Identifier of the pool and oracle\\n    uint24 poolNonce; // Initial nonce of the deployed pool\\n    uint16 cardinality; // Initial cardinality of the deployed pool\\n  }\\n\\n  // STATE VARIABLES\\n\\n  /// @return _oracleInitCodeHash The oracle creation code hash used to calculate their address\\n  //solhint-disable-next-line func-name-mixedcase\\n  function ORACLE_INIT_CODE_HASH() external view returns (bytes32 _oracleInitCodeHash);\\n\\n  /// @return _dataReceiver The address of the DataReceiver for the oracles to consult\\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\\n\\n  /// @return _poolSalt The id of both the oracle and the pool\\n  /// @return _poolNonce The initial nonce of the pool data\\n  /// @return _cardinality The size of the observations memory storage\\n  function oracleParameters()\\n    external\\n    view\\n    returns (\\n      bytes32 _poolSalt,\\n      uint24 _poolNonce,\\n      uint16 _cardinality\\n    );\\n\\n  /// @return _initialCardinality The initial size of the observations memory storage for newly deployed pools\\n  function initialCardinality() external view returns (uint16 _initialCardinality);\\n\\n  // EVENTS\\n\\n  /// @notice Emitted when a new oracle is deployed\\n  /// @param _poolSalt The id of both the oracle and the pool\\n  /// @param _oracle The address of the deployed oracle\\n  /// @param _initialNonce The initial nonce of the pool data\\n  event OracleDeployed(bytes32 indexed _poolSalt, address indexed _oracle, uint24 _initialNonce);\\n\\n  /// @notice Emitted when a new DataReceiver is set\\n  /// @param _dataReceiver The address of the new DataReceiver\\n  event DataReceiverSet(IDataReceiver _dataReceiver);\\n\\n  /// @notice Emitted when a new initial oracle cardinality is set\\n  /// @param _initialCardinality The initial length of the observationCardinality array\\n  event InitialCardinalitySet(uint16 _initialCardinality);\\n\\n  // ERRORS\\n\\n  /// @notice Thrown when a contract other than the DataReceiver tries to deploy an oracle\\n  error OnlyDataReceiver();\\n\\n  // FUNCTIONS\\n\\n  /// @notice Deploys a new oracle given an inputted salt\\n  /// @dev Requires that the salt has not been deployed before\\n  /// @param _poolSalt Pool salt that deterministically binds an oracle with a pool\\n  /// @return _oracle The address of the newly deployed oracle\\n  function deployOracle(bytes32 _poolSalt, uint24 _poolNonce) external returns (IOracleSidechain _oracle);\\n\\n  /// @notice Allows governor to set a new allowed dataReceiver\\n  /// @dev Will disallow the previous dataReceiver\\n  /// @param _dataReceiver The address of the new allowed dataReceiver\\n  function setDataReceiver(IDataReceiver _dataReceiver) external;\\n\\n  /// @notice Allows governor to set a new initial cardinality for new oracles\\n  /// @param _initialCardinality The initial size of the observations memory storage for newly deployed pools\\n  function setInitialCardinality(uint16 _initialCardinality) external;\\n\\n  /// @notice Overrides UniV3Factory getPool mapping\\n  /// @param _tokenA The contract address of either token0 or token1\\n  /// @param _tokenB The contract address of the other token\\n  /// @param _fee The fee denominated in hundredths of a bip\\n  /// @return _oracle The oracle address\\n  function getPool(\\n    address _tokenA,\\n    address _tokenB,\\n    uint24 _fee\\n  ) external view returns (IOracleSidechain _oracle);\\n\\n  /// @notice Tracks the addresses of the oracle by poolSalt\\n  /// @param _poolSalt Identifier of both the pool and the oracle\\n  /// @return _oracle The address (if deployed) of the correspondant oracle\\n  function getPool(bytes32 _poolSalt) external view returns (IOracleSidechain _oracle);\\n\\n  /// @param _tokenA The contract address of either token0 or token1\\n  /// @param _tokenB The contract address of the other token\\n  /// @param _fee The fee denominated in hundredths of a bip\\n  /// @return _poolSalt Pool salt for inquired parameters\\n  function getPoolSalt(\\n    address _tokenA,\\n    address _tokenB,\\n    uint24 _fee\\n  ) external view returns (bytes32 _poolSalt);\\n}\\n\",\"keccak256\":\"0xc32bfc32a274923ce1a089acc024396e702ae354773f0ac0a683e43ded904954\",\"license\":\"MIT\"},\"solidity/interfaces/IOracleSidechain.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IOracleFactory} from './IOracleFactory.sol';\\n\\ninterface IOracleSidechain {\\n  // STRUCTS\\n\\n  struct ObservationData {\\n    uint32 blockTimestamp;\\n    int24 tick;\\n  }\\n\\n  // STATE VARIABLES\\n\\n  /// @return _oracleFactory The address of the OracleFactory\\n  function factory() external view returns (IOracleFactory _oracleFactory);\\n\\n  /// @return _token0 The mainnet address of the Token0 of the oracle\\n  function token0() external view returns (address _token0);\\n\\n  /// @return _token1 The mainnet address of the Token1 of the oracle\\n  function token1() external view returns (address _token1);\\n\\n  /// @return _fee The fee identifier of the pool\\n  function fee() external view returns (uint24 _fee);\\n\\n  /// @return _poolSalt The identifier of both the pool and the oracle\\n  function poolSalt() external view returns (bytes32 _poolSalt);\\n\\n  /// @return _poolNonce Last recorded nonce of the pool history\\n  function poolNonce() external view returns (uint24 _poolNonce);\\n\\n  /// @notice Replicates the UniV3Pool slot0 behaviour (semi-compatible)\\n  /// @return _sqrtPriceX96 Used to maintain compatibility with Uniswap V3\\n  /// @return _tick Used to maintain compatibility with Uniswap V3\\n  /// @return _observationIndex The index of the last oracle observation that was written,\\n  /// @return _observationCardinality The current maximum number of observations stored in the pool,\\n  /// @return _observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n  /// @return _feeProtocol Used to maintain compatibility with Uniswap V3\\n  /// @return _unlocked Used to track if a pool information was already verified\\n  function slot0()\\n    external\\n    view\\n    returns (\\n      uint160 _sqrtPriceX96,\\n      int24 _tick,\\n      uint16 _observationIndex,\\n      uint16 _observationCardinality,\\n      uint16 _observationCardinalityNext,\\n      uint8 _feeProtocol,\\n      bool _unlocked\\n    );\\n\\n  /// @notice Returns data about a specific observation index\\n  /// @param _index The element of the observations array to fetch\\n  /// @return _blockTimestamp The timestamp of the observation,\\n  /// @return _tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n  /// @return _secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n  /// @return _initialized whether the observation has been initialized and the values are safe to use\\n  function observations(uint256 _index)\\n    external\\n    view\\n    returns (\\n      uint32 _blockTimestamp,\\n      int56 _tickCumulative,\\n      uint160 _secondsPerLiquidityCumulativeX128,\\n      bool _initialized\\n    );\\n\\n  // EVENTS\\n\\n  /// @notice Emitted when the pool information is verified\\n  /// @param _poolSalt Identifier of the pool and the oracle\\n  /// @param _token0 The contract address of either token0 or token1\\n  /// @param _token1 The contract address of the other token\\n  /// @param _fee The fee denominated in hundredths of a bip\\n  event PoolInfoInitialized(bytes32 indexed _poolSalt, address _token0, address _token1, uint24 _fee);\\n\\n  /// @notice Emitted by the oracle to hint indexers that the pool state has changed\\n  /// @dev Imported from IUniswapV3PoolEvents (semi-compatible)\\n  /// @param _sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\\n  /// @param _tick The log base 1.0001 of price of the pool after the swap\\n  event Swap(address indexed, address indexed, int256, int256, uint160 _sqrtPriceX96, uint128, int24 _tick);\\n\\n  /// @notice Emitted by the oracle for increases to the number of observations that can be stored\\n  /// @dev Imported from IUniswapV3PoolEvents (fully-compatible)\\n  /// @param _observationCardinalityNextOld The previous value of the next observation cardinality\\n  /// @param _observationCardinalityNextNew The updated value of the next observation cardinality\\n  event IncreaseObservationCardinalityNext(uint16 _observationCardinalityNextOld, uint16 _observationCardinalityNextNew);\\n\\n  // ERRORS\\n\\n  /// @notice Thrown if the pool info is already initialized or if the observationCardinalityNext is already increased\\n  error AI();\\n\\n  /// @notice Thrown if the pool info does not correspond to the pool salt\\n  error InvalidPool();\\n\\n  /// @notice Thrown if the DataReceiver contract is not the one calling for writing observations\\n  error OnlyDataReceiver();\\n\\n  /// @notice Thrown if the OracleFactory contract is not the one calling for increasing observationCardinalityNext\\n  error OnlyFactory();\\n\\n  // FUNCTIONS\\n\\n  /// @notice Permisionless method to verify token0, token1 and fee\\n  /// @dev Before verified, token0 and token1 views will return address(0)\\n  /// @param _tokenA The contract address of either token0 or token1\\n  /// @param _tokenB The contract address of the other token\\n  /// @param _fee The fee denominated in hundredths of a bip\\n  function initializePoolInfo(\\n    address _tokenA,\\n    address _tokenB,\\n    uint24 _fee\\n  ) external;\\n\\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n  /// @dev Imported from UniV3Pool (semi compatible, optimistically extrapolates)\\n  /// @param _secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n  /// @return _tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n  /// @return _secondsCumulativeX128s Cumulative seconds as of each `secondsAgos` from the current block timestamp\\n  function observe(uint32[] calldata _secondsAgos)\\n    external\\n    view\\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsCumulativeX128s);\\n\\n  /// @notice Permisioned method to push a dataset to update\\n  /// @param _observationsData Array of tuples containing the dataset\\n  /// @param _poolNonce Nonce of the observation broadcast\\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external returns (bool _written);\\n\\n  /// @notice Permisioned method to increase the cardinalityNext value\\n  /// @param _observationCardinalityNext The new next length of the observations array\\n  function increaseObservationCardinalityNext(uint16 _observationCardinalityNext) external;\\n}\\n\",\"keccak256\":\"0xa90206e3de00ad866b7f4792ce29220ee0ca561d59629ba638a31c4d6fd3941b\",\"license\":\"MIT\"},\"solidity/interfaces/bridges/IBridgeReceiverAdapter.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IBaseErrors} from '@defi-wonderland/solidity-utils/solidity/interfaces/IBaseErrors.sol';\\nimport {IDataReceiver} from '../IDataReceiver.sol';\\nimport {IOracleSidechain} from '../IOracleSidechain.sol';\\n\\ninterface IBridgeReceiverAdapter is IBaseErrors {\\n  // STATE VARIABLES\\n\\n  /// @notice Gets the address of the DataReceiver contract\\n  /// @return _dataReceiver Address of the DataReceiver contract\\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\\n\\n  /* NOTE: callback methods should be here declared */\\n}\\n\",\"keccak256\":\"0x49e5c9c6a28521933a3f2b01a529fbae9aac1edd71dbe904586a2f06148b1974\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60a060405234801561001057600080fd5b50604051610fa0380380610fa083398101604081905261002f916100bc565b816001600160a01b0381166100575760405163d92e233d60e01b815260040160405180910390fd5b600080546001600160a01b0319166001600160a01b0392831617905581166100925760405163d92e233d60e01b815260040160405180910390fd5b6001600160a01b0316608052506100f6565b6001600160a01b03811681146100b957600080fd5b50565b600080604083850312156100cf57600080fd5b82516100da816100a4565b60208401519092506100eb816100a4565b809150509250929050565b608051610e8161011f600039600081816101640152818161045801526104fc0152610e816000f3fe608060405234801561001057600080fd5b506004361061009e5760003560e01c8063b893cce211610066578063b893cce21461012c578063c7f7fb901461015f578063d34ad40914610186578063e3056a3414610199578063f235757f146101ac57600080fd5b80630c340a24146100a35780630ddb5dd2146100d357806313f6986d146100e85780636607baca146100f0578063954e863e14610119575b600080fd5b6000546100b6906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100e66100e1366004610a69565b6101bf565b005b6100e661027f565b6100b66100fe366004610ad5565b6002602052600090815260409020546001600160a01b031681565b6100e6610127366004610b11565b6102b4565b61014f61013a366004610b4a565b60036020526000908152604090205460ff1681565b60405190151581526020016100ca565b6100b67f000000000000000000000000000000000000000000000000000000000000000081565b6100e6610194366004610bff565b6102ed565b6001546100b6906001600160a01b031681565b6100e66101ba366004610b4a565b61032d565b6000546001600160a01b031633146101ea5760405163070545c960e51b815260040160405180910390fd5b8281811461020e576040516001621398b960e31b0319815260040160405180910390fd5b60005b818110156102775761026f86868381811061022e5761022e610d0b565b90506020020160208101906102439190610b4a565b85858481811061025557610255610d0b565b905060200201602081019061026a9190610d21565b610364565b600101610211565b505050505050565b6001546001600160a01b031633146102aa57604051639ba0305d60e01b815260040160405180910390fd5b6102b26103c7565b565b6000546001600160a01b031633146102df5760405163070545c960e51b815260040160405180910390fd5b6102e98282610364565b5050565b3360009081526003602052604090205460ff1661031d576040516360ece74160e01b815260040160405180910390fd5b610328838383610425565b505050565b6000546001600160a01b031633146103585760405163070545c960e51b815260040160405180910390fd5b61036181610958565b50565b6001600160a01b038216600081815260036020908152604091829020805460ff19168515159081179091558251938452908301527f3cece36ac6216147f57b10bb30975f82b18b8b290a7925c322277e684afcce4a910160405180910390a15050565b60018054600080546001600160a01b0383166001600160a01b031991821681179092559091169091556040519081527f5d5d6e01b731c3e68060f7fe13156f6197d4aeffc2d6f498e34c717ae616b7349060200160405180910390a1565b6000828152600260205260409020546001600160a01b03168061059c5760405163f6c0092760e01b8152600481018490527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f6c0092790602401602060405180830381865afa1580156104a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104cb9190610d3e565b90506001600160a01b03811661057457604051632e60fe9b60e11b81526004810184905262ffffff831660248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635cc1fd36906044016020604051808303816000875af115801561054d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105719190610d3e565b90505b600083815260026020526040902080546001600160a01b0319166001600160a01b0383161790555b6040516308f944b560e21b81526001600160a01b038216906323e512d4906105ca9087908690600401610d5b565b6020604051808303816000875af11580156105e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060d9190610dc0565b15610656576040805162ffffff8416815233602082015284917f9a777601844e27c439fe9f23f4ada7ea2b67551ea35b07439e3dad53e0e369cd910160405180910390a2610952565b6000816001600160a01b0316639fdbd4d76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610696573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ba9190610ddd565b90508262ffffff168162ffffff1611156106e757604051630a96dcbd60e11b815260040160405180910390fd5b60005b855181101561078757600085815260046020908152604080832062ffffff881684529091529020865187908390811061072557610725610d0b565b6020908102919091018101518254600181018455600093845292829020815193018054919092015162ffffff166401000000000266ffffffffffffff1990911663ffffffff9093169290921791909117905561078081610e10565b90506106ea565b506040805162ffffff8516815233602082015285917fca8a146eac241d31b0d3d0650d8747b21a7d1f1a21c55abdbb7209740d742dd1910160405180910390a25b8262ffffff168162ffffff161161095057600084815260046020908152604080832062ffffff85168452825280832080548251818502810185019093528083529193909284015b82821015610856576000848152602090819020604080518082019091529084015463ffffffff81168252640100000000900460020b8183015282526001909201910161080f565b505050509450600085511115610950576040516308f944b560e21b81526001600160a01b038316906323e512d4906108949088908590600401610d5b565b6020604051808303816000875af11580156108b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d79190610dc0565b506040805162ffffff8316815233602082015285917f9a777601844e27c439fe9f23f4ada7ea2b67551ea35b07439e3dad53e0e369cd910160405180910390a2600084815260046020908152604080832062ffffff85168452909152812061093e916109e1565b8061094881610e29565b9150506107c8565b505b50505050565b6001600160a01b03811661097f5760405163d92e233d60e01b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b038381169182179092556000546040805191909316815260208101919091527f6353ec38ac394f8be94bfafcdd3580d356470599059eaeebedc3207e1cc03dec910160405180910390a150565b508054600082559060005260206000209081019061036191905b80821115610a1957805466ffffffffffffff191681556001016109fb565b5090565b60008083601f840112610a2f57600080fd5b50813567ffffffffffffffff811115610a4757600080fd5b6020830191508360208260051b8501011115610a6257600080fd5b9250929050565b60008060008060408587031215610a7f57600080fd5b843567ffffffffffffffff80821115610a9757600080fd5b610aa388838901610a1d565b90965094506020870135915080821115610abc57600080fd5b50610ac987828801610a1d565b95989497509550505050565b600060208284031215610ae757600080fd5b5035919050565b6001600160a01b038116811461036157600080fd5b801515811461036157600080fd5b60008060408385031215610b2457600080fd5b8235610b2f81610aee565b91506020830135610b3f81610b03565b809150509250929050565b600060208284031215610b5c57600080fd5b8135610b6781610aee565b9392505050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610ba757610ba7610b6e565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715610bd657610bd6610b6e565b604052919050565b62ffffff8116811461036157600080fd5b8035610bfa81610bde565b919050565b600080600060608486031215610c1457600080fd5b833567ffffffffffffffff80821115610c2c57600080fd5b818601915086601f830112610c4057600080fd5b8135602082821115610c5457610c54610b6e565b610c62818360051b01610bad565b828152818101935060069290921b840181019189831115610c8257600080fd5b938101935b82851015610cea576040858b031215610ca05760008081fd5b610ca8610b84565b853563ffffffff81168114610cbd5760008081fd5b815285830135600281900b8114610cd45760008081fd5b8184015284526040949094019392810192610c87565b96508701359450610d02925050604086019050610bef565b90509250925092565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610d3357600080fd5b8135610b6781610b03565b600060208284031215610d5057600080fd5b8151610b6781610aee565b60408082528351828201819052600091906020906060850190828801855b82811015610da7578151805163ffffffff16855285015160020b858501529285019290840190600101610d79565b50505062ffffff95909516930192909252509092915050565b600060208284031215610dd257600080fd5b8151610b6781610b03565b600060208284031215610def57600080fd5b8151610b6781610bde565b634e487b7160e01b600052601160045260246000fd5b600060018201610e2257610e22610dfa565b5060010190565b600062ffffff808316818103610e4157610e41610dfa565b600101939250505056fea264697066735822122034fd09118d3d0be727d85a098f8ee3713b14cb27c0ce5bd2232a496b84d3abcf64736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061009e5760003560e01c8063b893cce211610066578063b893cce21461012c578063c7f7fb901461015f578063d34ad40914610186578063e3056a3414610199578063f235757f146101ac57600080fd5b80630c340a24146100a35780630ddb5dd2146100d357806313f6986d146100e85780636607baca146100f0578063954e863e14610119575b600080fd5b6000546100b6906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100e66100e1366004610a69565b6101bf565b005b6100e661027f565b6100b66100fe366004610ad5565b6002602052600090815260409020546001600160a01b031681565b6100e6610127366004610b11565b6102b4565b61014f61013a366004610b4a565b60036020526000908152604090205460ff1681565b60405190151581526020016100ca565b6100b67f000000000000000000000000000000000000000000000000000000000000000081565b6100e6610194366004610bff565b6102ed565b6001546100b6906001600160a01b031681565b6100e66101ba366004610b4a565b61032d565b6000546001600160a01b031633146101ea5760405163070545c960e51b815260040160405180910390fd5b8281811461020e576040516001621398b960e31b0319815260040160405180910390fd5b60005b818110156102775761026f86868381811061022e5761022e610d0b565b90506020020160208101906102439190610b4a565b85858481811061025557610255610d0b565b905060200201602081019061026a9190610d21565b610364565b600101610211565b505050505050565b6001546001600160a01b031633146102aa57604051639ba0305d60e01b815260040160405180910390fd5b6102b26103c7565b565b6000546001600160a01b031633146102df5760405163070545c960e51b815260040160405180910390fd5b6102e98282610364565b5050565b3360009081526003602052604090205460ff1661031d576040516360ece74160e01b815260040160405180910390fd5b610328838383610425565b505050565b6000546001600160a01b031633146103585760405163070545c960e51b815260040160405180910390fd5b61036181610958565b50565b6001600160a01b038216600081815260036020908152604091829020805460ff19168515159081179091558251938452908301527f3cece36ac6216147f57b10bb30975f82b18b8b290a7925c322277e684afcce4a910160405180910390a15050565b60018054600080546001600160a01b0383166001600160a01b031991821681179092559091169091556040519081527f5d5d6e01b731c3e68060f7fe13156f6197d4aeffc2d6f498e34c717ae616b7349060200160405180910390a1565b6000828152600260205260409020546001600160a01b03168061059c5760405163f6c0092760e01b8152600481018490527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063f6c0092790602401602060405180830381865afa1580156104a7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104cb9190610d3e565b90506001600160a01b03811661057457604051632e60fe9b60e11b81526004810184905262ffffff831660248201527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031690635cc1fd36906044016020604051808303816000875af115801561054d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105719190610d3e565b90505b600083815260026020526040902080546001600160a01b0319166001600160a01b0383161790555b6040516308f944b560e21b81526001600160a01b038216906323e512d4906105ca9087908690600401610d5b565b6020604051808303816000875af11580156105e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060d9190610dc0565b15610656576040805162ffffff8416815233602082015284917f9a777601844e27c439fe9f23f4ada7ea2b67551ea35b07439e3dad53e0e369cd910160405180910390a2610952565b6000816001600160a01b0316639fdbd4d76040518163ffffffff1660e01b8152600401602060405180830381865afa158015610696573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106ba9190610ddd565b90508262ffffff168162ffffff1611156106e757604051630a96dcbd60e11b815260040160405180910390fd5b60005b855181101561078757600085815260046020908152604080832062ffffff881684529091529020865187908390811061072557610725610d0b565b6020908102919091018101518254600181018455600093845292829020815193018054919092015162ffffff166401000000000266ffffffffffffff1990911663ffffffff9093169290921791909117905561078081610e10565b90506106ea565b506040805162ffffff8516815233602082015285917fca8a146eac241d31b0d3d0650d8747b21a7d1f1a21c55abdbb7209740d742dd1910160405180910390a25b8262ffffff168162ffffff161161095057600084815260046020908152604080832062ffffff85168452825280832080548251818502810185019093528083529193909284015b82821015610856576000848152602090819020604080518082019091529084015463ffffffff81168252640100000000900460020b8183015282526001909201910161080f565b505050509450600085511115610950576040516308f944b560e21b81526001600160a01b038316906323e512d4906108949088908590600401610d5b565b6020604051808303816000875af11580156108b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d79190610dc0565b506040805162ffffff8316815233602082015285917f9a777601844e27c439fe9f23f4ada7ea2b67551ea35b07439e3dad53e0e369cd910160405180910390a2600084815260046020908152604080832062ffffff85168452909152812061093e916109e1565b8061094881610e29565b9150506107c8565b505b50505050565b6001600160a01b03811661097f5760405163d92e233d60e01b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b038381169182179092556000546040805191909316815260208101919091527f6353ec38ac394f8be94bfafcdd3580d356470599059eaeebedc3207e1cc03dec910160405180910390a150565b508054600082559060005260206000209081019061036191905b80821115610a1957805466ffffffffffffff191681556001016109fb565b5090565b60008083601f840112610a2f57600080fd5b50813567ffffffffffffffff811115610a4757600080fd5b6020830191508360208260051b8501011115610a6257600080fd5b9250929050565b60008060008060408587031215610a7f57600080fd5b843567ffffffffffffffff80821115610a9757600080fd5b610aa388838901610a1d565b90965094506020870135915080821115610abc57600080fd5b50610ac987828801610a1d565b95989497509550505050565b600060208284031215610ae757600080fd5b5035919050565b6001600160a01b038116811461036157600080fd5b801515811461036157600080fd5b60008060408385031215610b2457600080fd5b8235610b2f81610aee565b91506020830135610b3f81610b03565b809150509250929050565b600060208284031215610b5c57600080fd5b8135610b6781610aee565b9392505050565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715610ba757610ba7610b6e565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715610bd657610bd6610b6e565b604052919050565b62ffffff8116811461036157600080fd5b8035610bfa81610bde565b919050565b600080600060608486031215610c1457600080fd5b833567ffffffffffffffff80821115610c2c57600080fd5b818601915086601f830112610c4057600080fd5b8135602082821115610c5457610c54610b6e565b610c62818360051b01610bad565b828152818101935060069290921b840181019189831115610c8257600080fd5b938101935b82851015610cea576040858b031215610ca05760008081fd5b610ca8610b84565b853563ffffffff81168114610cbd5760008081fd5b815285830135600281900b8114610cd45760008081fd5b8184015284526040949094019392810192610c87565b96508701359450610d02925050604086019050610bef565b90509250925092565b634e487b7160e01b600052603260045260246000fd5b600060208284031215610d3357600080fd5b8135610b6781610b03565b600060208284031215610d5057600080fd5b8151610b6781610aee565b60408082528351828201819052600091906020906060850190828801855b82811015610da7578151805163ffffffff16855285015160020b858501529285019290840190600101610d79565b50505062ffffff95909516930192909252509092915050565b600060208284031215610dd257600080fd5b8151610b6781610b03565b600060208284031215610def57600080fd5b8151610b6781610bde565b634e487b7160e01b600052601160045260246000fd5b600060018201610e2257610e22610dfa565b5060010190565b600062ffffff808316818103610e4157610e41610dfa565b600101939250505056fea264697066735822122034fd09118d3d0be727d85a098f8ee3713b14cb27c0ce5bd2232a496b84d3abcf64736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "addObservations((uint32,int24)[],bytes32,uint24)": {
        "params": {
          "_observationsData": "Array of tuples containing the dataset",
          "_poolNonce": "Nonce of the observation broadcast",
          "_poolSalt": "Identifier of the pool to fetch"
        }
      },
      "setPendingGovernor(address)": {
        "params": {
          "_pendingGovernor": "Address of the proposed new governor"
        }
      },
      "whitelistAdapter(address,bool)": {
        "params": {
          "_isWhitelisted": "New whitelisting status",
          "_receiverAdapter": "Address of the adapter"
        }
      },
      "whitelistAdapters(address[],bool[])": {
        "params": {
          "_isWhitelisted": "Array of whitelisting status for each address",
          "_receiverAdapters": "Array of addresses of the adapter"
        }
      }
    },
    "stateVariables": {
      "deployedOracles": {
        "params": {
          "_poolSalt": "The identifier of the oracle"
        },
        "return": "The address of the correspondant Oracle",
        "returns": {
          "_0": "The address of the correspondant Oracle"
        }
      },
      "oracleFactory": {
        "return": "The address of the OracleFactory",
        "returns": {
          "_0": "The address of the OracleFactory"
        }
      },
      "whitelistedAdapters": {
        "params": {
          "_adapter": "Address of the bridge adapter to consult"
        },
        "return": "Whether a bridge adapter is whitelisted",
        "returns": {
          "_0": "Whether a bridge adapter is whitelisted"
        }
      }
    },
    "title": "The DataReceiver contract",
    "version": 1
  },
  "userdoc": {
    "errors": {
      "InvalidAddress()": [
        {
          "notice": "Thrown if an address is invalid"
        }
      ],
      "InvalidAmount()": [
        {
          "notice": "Thrown if an amount is invalid"
        }
      ],
      "LengthMismatch()": [
        {
          "notice": "Thrown if the lengths of a set of lists mismatch"
        }
      ],
      "ObservationsNotWritable()": [
        {
          "notice": "Thrown when the broadcast nonce is incorrect"
        }
      ],
      "OnlyGovernor()": [
        {
          "notice": "Thrown if a non-governor user tries to call a OnlyGovernor function"
        }
      ],
      "OnlyPendingGovernor()": [
        {
          "notice": "Thrown if a non-pending-governor user tries to call a OnlyPendingGovernor function"
        }
      ],
      "UnallowedAdapter()": [
        {
          "notice": "Thrown when a not-whitelisted adapter triggers an update"
        }
      ],
      "ZeroAddress()": [
        {
          "notice": "Thrown if an address is the zero address"
        }
      ],
      "ZeroAmount()": [
        {
          "notice": "Thrown if an amount is zero"
        }
      ]
    },
    "events": {
      "AdapterWhitelisted(address,bool)": {
        "notice": "Emitted when a new adapter whitelisting rule is set"
      },
      "ObservationsAdded(bytes32,uint24,address)": {
        "notice": "Emitted when a broadcast observation is succesfully processed"
      },
      "ObservationsCached(bytes32,uint24,address)": {
        "notice": "Emitted when a broadcast observation is cached for later processing"
      },
      "PendingGovernorAccepted(address)": {
        "notice": "Emitted when a new governor is set"
      },
      "PendingGovernorSet(address,address)": {
        "notice": "Emitted when a new pending governor is set"
      }
    },
    "kind": "user",
    "methods": {
      "acceptPendingGovernor()": {
        "notice": "Allows a proposed governor to accept the governance"
      },
      "addObservations((uint32,int24)[],bytes32,uint24)": {
        "notice": "Allows whitelisted bridge adapters to push a broadcast"
      },
      "deployedOracles(bytes32)": {
        "notice": "Tracks already deployed oracles"
      },
      "setPendingGovernor(address)": {
        "notice": "Allows a governor to propose a new governor"
      },
      "whitelistAdapter(address,bool)": {
        "notice": "Allows governance to set an adapter whitelisted state"
      },
      "whitelistAdapters(address[],bool[])": {
        "notice": "Allows governance to batch set adapters whitelisted state"
      },
      "whitelistedAdapters(address)": {
        "notice": "Tracks the whitelisting of bridge adapters"
      }
    },
    "notice": "Handles reception of broadcast data and delivers it to correspondant oracle",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8014,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "governor",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 8017,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "pendingGovernor",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 15164,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "deployedOracles",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_bytes32,t_contract(IOracleSidechain)18533)"
      },
      {
        "astId": 15170,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "whitelistedAdapters",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_contract(IBridgeReceiverAdapter)18668,t_bool)"
      },
      {
        "astId": 15178,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "_cachedObservations",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_bytes32,t_mapping(t_uint24,t_array(t_struct(ObservationData)18375_storage)dyn_storage))"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_struct(ObservationData)18375_storage)dyn_storage": {
        "base": "t_struct(ObservationData)18375_storage",
        "encoding": "dynamic_array",
        "label": "struct IOracleSidechain.ObservationData[]",
        "numberOfBytes": "32"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IBridgeReceiverAdapter)18668": {
        "encoding": "inplace",
        "label": "contract IBridgeReceiverAdapter",
        "numberOfBytes": "20"
      },
      "t_contract(IOracleSidechain)18533": {
        "encoding": "inplace",
        "label": "contract IOracleSidechain",
        "numberOfBytes": "20"
      },
      "t_int24": {
        "encoding": "inplace",
        "label": "int24",
        "numberOfBytes": "3"
      },
      "t_mapping(t_bytes32,t_contract(IOracleSidechain)18533)": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => contract IOracleSidechain)",
        "numberOfBytes": "32",
        "value": "t_contract(IOracleSidechain)18533"
      },
      "t_mapping(t_bytes32,t_mapping(t_uint24,t_array(t_struct(ObservationData)18375_storage)dyn_storage))": {
        "encoding": "mapping",
        "key": "t_bytes32",
        "label": "mapping(bytes32 => mapping(uint24 => struct IOracleSidechain.ObservationData[]))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_uint24,t_array(t_struct(ObservationData)18375_storage)dyn_storage)"
      },
      "t_mapping(t_contract(IBridgeReceiverAdapter)18668,t_bool)": {
        "encoding": "mapping",
        "key": "t_contract(IBridgeReceiverAdapter)18668",
        "label": "mapping(contract IBridgeReceiverAdapter => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_uint24,t_array(t_struct(ObservationData)18375_storage)dyn_storage)": {
        "encoding": "mapping",
        "key": "t_uint24",
        "label": "mapping(uint24 => struct IOracleSidechain.ObservationData[])",
        "numberOfBytes": "32",
        "value": "t_array(t_struct(ObservationData)18375_storage)dyn_storage"
      },
      "t_struct(ObservationData)18375_storage": {
        "encoding": "inplace",
        "label": "struct IOracleSidechain.ObservationData",
        "members": [
          {
            "astId": 18372,
            "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
            "label": "blockTimestamp",
            "offset": 0,
            "slot": "0",
            "type": "t_uint32"
          },
          {
            "astId": 18374,
            "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
            "label": "tick",
            "offset": 4,
            "slot": "0",
            "type": "t_int24"
          }
        ],
        "numberOfBytes": "32"
      },
      "t_uint24": {
        "encoding": "inplace",
        "label": "uint24",
        "numberOfBytes": "3"
      },
      "t_uint32": {
        "encoding": "inplace",
        "label": "uint32",
        "numberOfBytes": "4"
      }
    }
  }
}