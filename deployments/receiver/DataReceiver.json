{
  "address": "0x459D8201ADb265B83D1AAB0e1dbF4B2943D09644",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_governance",
          "type": "address"
        },
        {
          "internalType": "contract IOracleFactory",
          "name": "_oracleFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "LengthMismatch",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "NoGovernanceZeroAddress",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "ObservationsNotWritable",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyGovernance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "OnlyPendingGovernance",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "UnallowedAdapter",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "contract IBridgeReceiverAdapter",
          "name": "_adapter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "bool",
          "name": "_isAllowed",
          "type": "bool"
        }
      ],
      "name": "AdapterWhitelisted",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_pendingGovernance",
          "type": "address"
        }
      ],
      "name": "GovernanceProposal",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_governance",
          "type": "address"
        }
      ],
      "name": "GovernanceSet",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_user",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "blockTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "int24",
              "name": "tick",
              "type": "int24"
            }
          ],
          "indexed": false,
          "internalType": "struct IOracleSidechain.ObservationData[]",
          "name": "_observationsData",
          "type": "tuple[]"
        }
      ],
      "name": "ObservationsAdded",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "acceptGovernance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "uint32",
              "name": "blockTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "int24",
              "name": "tick",
              "type": "int24"
            }
          ],
          "internalType": "struct IOracleSidechain.ObservationData[]",
          "name": "_observationsData",
          "type": "tuple[]"
        },
        {
          "internalType": "address",
          "name": "_token0",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_token1",
          "type": "address"
        },
        {
          "internalType": "uint24",
          "name": "_fee",
          "type": "uint24"
        }
      ],
      "name": "addObservations",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "governance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "oracleFactory",
      "outputs": [
        {
          "internalType": "contract IOracleFactory",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "pendingGovernance",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_governance",
          "type": "address"
        }
      ],
      "name": "setGovernance",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBridgeReceiverAdapter",
          "name": "_receiverAdapter",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "_isWhitelisted",
          "type": "bool"
        }
      ],
      "name": "whitelistAdapter",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBridgeReceiverAdapter[]",
          "name": "_receiverAdapters",
          "type": "address[]"
        },
        {
          "internalType": "bool[]",
          "name": "_isWhitelisted",
          "type": "bool[]"
        }
      ],
      "name": "whitelistAdapters",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IBridgeReceiverAdapter",
          "name": "",
          "type": "address"
        }
      ],
      "name": "whitelistedAdapters",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xf51c104ea94c0c942a309f05b0702d5272458f7f7082877fa769cac4c44cf462",
  "receipt": {
    "to": null,
    "from": "0x57B067e4E27558FE2c60fCE86941011cB5F5A4FD",
    "contractAddress": "0x459D8201ADb265B83D1AAB0e1dbF4B2943D09644",
    "transactionIndex": 18,
    "gasUsed": "652496",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x7c5a8f1c22b73c4575f2fcb68b26bb405c801cd705a8ff6627b7176d5e238817",
    "transactionHash": "0xf51c104ea94c0c942a309f05b0702d5272458f7f7082877fa769cac4c44cf462",
    "logs": [],
    "blockNumber": 7276312,
    "cumulativeGasUsed": "21517352",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x57B067e4E27558FE2c60fCE86941011cB5F5A4FD",
    "0x3EE6f90Abb8Af28fA0084Ee55d82b3808A1d03a7"
  ],
  "numDeployments": 1,
  "solcInputHash": "d9c8f4a75f1081f77b146589b1a5d995",
  "metadata": "{\"compiler\":{\"version\":\"0.8.15+commit.e14f2714\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"},{\"internalType\":\"contract IOracleFactory\",\"name\":\"_oracleFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"LengthMismatch\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"NoGovernanceZeroAddress\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"ObservationsNotWritable\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"OnlyPendingGovernance\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"UnallowedAdapter\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"contract IBridgeReceiverAdapter\",\"name\":\"_adapter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"bool\",\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"AdapterWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_pendingGovernance\",\"type\":\"address\"}],\"name\":\"GovernanceProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"GovernanceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_user\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"indexed\":false,\"internalType\":\"struct IOracleSidechain.ObservationData[]\",\"name\":\"_observationsData\",\"type\":\"tuple[]\"}],\"name\":\"ObservationsAdded\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"acceptGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"uint32\",\"name\":\"blockTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"}],\"internalType\":\"struct IOracleSidechain.ObservationData[]\",\"name\":\"_observationsData\",\"type\":\"tuple[]\"},{\"internalType\":\"address\",\"name\":\"_token0\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_token1\",\"type\":\"address\"},{\"internalType\":\"uint24\",\"name\":\"_fee\",\"type\":\"uint24\"}],\"name\":\"addObservations\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"governance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"oracleFactory\",\"outputs\":[{\"internalType\":\"contract IOracleFactory\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"pendingGovernance\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_governance\",\"type\":\"address\"}],\"name\":\"setGovernance\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridgeReceiverAdapter\",\"name\":\"_receiverAdapter\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"whitelistAdapter\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridgeReceiverAdapter[]\",\"name\":\"_receiverAdapters\",\"type\":\"address[]\"},{\"internalType\":\"bool[]\",\"name\":\"_isWhitelisted\",\"type\":\"bool[]\"}],\"name\":\"whitelistAdapters\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IBridgeReceiverAdapter\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedAdapters\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"setGovernance(address)\":{\"params\":{\"_governance\":\"The address being proposed as the new governance\"}}},\"version\":1},\"userdoc\":{\"errors\":{\"NoGovernanceZeroAddress()\":[{\"notice\":\"Throws if trying to set governance to zero address\"}],\"OnlyGovernance()\":[{\"notice\":\"Throws if the caller of the function is not governance\"}],\"OnlyPendingGovernance()\":[{\"notice\":\"Throws if the caller of the function is not pendingGovernance\"}]},\"events\":{\"GovernanceProposal(address)\":{\"notice\":\"Emitted when a new governance is proposed\"},\"GovernanceSet(address)\":{\"notice\":\"Emitted when pendingGovernance accepts to be governance\"}},\"kind\":\"user\",\"methods\":{\"acceptGovernance()\":{\"notice\":\"Changes the governance from the current governance to the previously proposed address\"},\"governance()\":{\"notice\":\"Stores the governance address\"},\"pendingGovernance()\":{\"notice\":\"Stores the pendingGovernance address\"},\"setGovernance(address)\":{\"notice\":\"Proposes a new address to be governance\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"solidity/contracts/DataReceiver.sol\":\"DataReceiver\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@uniswap/v3-core/contracts/libraries/Oracle.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/// @title Oracle\\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\\n/// @dev Instances of stored oracle data, \\\"observations\\\", are collected in the oracle array\\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\\n/// Observations are overwritten when the full length of the oracle array is populated.\\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\\nlibrary Oracle {\\n    error I();\\n    error OLD();\\n\\n    struct Observation {\\n        // the block timestamp of the observation\\n        uint32 blockTimestamp;\\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\\n        int56 tickCumulative;\\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\\n        uint160 secondsPerLiquidityCumulativeX128;\\n        // whether or not the observation is initialized\\n        bool initialized;\\n    }\\n\\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\\n    /// @param last The specified observation to be transformed\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param tick The active tick at the time of the new observation\\n    /// @param liquidity The total in-range liquidity at the time of the new observation\\n    /// @return Observation The newly populated observation\\n    function transform(\\n        Observation memory last,\\n        uint32 blockTimestamp,\\n        int24 tick,\\n        uint128 liquidity\\n    ) private pure returns (Observation memory) {\\n        unchecked {\\n            uint32 delta = blockTimestamp - last.blockTimestamp;\\n            return\\n                Observation({\\n                    blockTimestamp: blockTimestamp,\\n                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\\n                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\\n                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\\n                    initialized: true\\n                });\\n        }\\n    }\\n\\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\\n    /// @param self The stored oracle array\\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\\n    /// @return cardinality The number of populated elements in the oracle array\\n    /// @return cardinalityNext The new length of the oracle array, independent of population\\n    function initialize(Observation[65535] storage self, uint32 time)\\n        internal\\n        returns (uint16 cardinality, uint16 cardinalityNext)\\n    {\\n        self[0] = Observation({\\n            blockTimestamp: time,\\n            tickCumulative: 0,\\n            secondsPerLiquidityCumulativeX128: 0,\\n            initialized: true\\n        });\\n        return (1, 1);\\n    }\\n\\n    /// @notice Writes an oracle observation to the array\\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\\n    /// @param self The stored oracle array\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param blockTimestamp The timestamp of the new observation\\n    /// @param tick The active tick at the time of the new observation\\n    /// @param liquidity The total in-range liquidity at the time of the new observation\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @param cardinalityNext The new length of the oracle array, independent of population\\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\\n    /// @return cardinalityUpdated The new cardinality of the oracle array\\n    function write(\\n        Observation[65535] storage self,\\n        uint16 index,\\n        uint32 blockTimestamp,\\n        int24 tick,\\n        uint128 liquidity,\\n        uint16 cardinality,\\n        uint16 cardinalityNext\\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\\n        unchecked {\\n            Observation memory last = self[index];\\n\\n            // early return if we've already written an observation this block\\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\\n\\n            // if the conditions are right, we can bump the cardinality\\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\\n                cardinalityUpdated = cardinalityNext;\\n            } else {\\n                cardinalityUpdated = cardinality;\\n            }\\n\\n            indexUpdated = (index + 1) % cardinalityUpdated;\\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\\n        }\\n    }\\n\\n    /// @notice Prepares the oracle array to store up to `next` observations\\n    /// @param self The stored oracle array\\n    /// @param current The current next cardinality of the oracle array\\n    /// @param next The proposed next cardinality which will be populated in the oracle array\\n    /// @return next The next cardinality which will be populated in the oracle array\\n    function grow(\\n        Observation[65535] storage self,\\n        uint16 current,\\n        uint16 next\\n    ) internal returns (uint16) {\\n        unchecked {\\n            if (current <= 0) revert I();\\n            // no-op if the passed next value isn't greater than the current next value\\n            if (next <= current) return current;\\n            // store in each slot to prevent fresh SSTOREs in swaps\\n            // this data will not be used because the initialized boolean is still false\\n            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\\n            return next;\\n        }\\n    }\\n\\n    /// @notice comparator for 32-bit timestamps\\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\\n    /// @param time A timestamp truncated to 32 bits\\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\\n    /// @param b From which to determine the relative position of `time`\\n    /// @return Whether `a` is chronologically <= `b`\\n    function lte(\\n        uint32 time,\\n        uint32 a,\\n        uint32 b\\n    ) private pure returns (bool) {\\n        unchecked {\\n            // if there hasn't been overflow, no need to adjust\\n            if (a <= time && b <= time) return a <= b;\\n\\n            uint256 aAdjusted = a > time ? a : a + 2**32;\\n            uint256 bAdjusted = b > time ? b : b + 2**32;\\n\\n            return aAdjusted <= bAdjusted;\\n        }\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\\n    /// The result may be the same observation, or adjacent observations.\\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation recorded before, or at, the target\\n    /// @return atOrAfter The observation recorded at, or after, the target\\n    function binarySearch(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 target,\\n        uint16 index,\\n        uint16 cardinality\\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        unchecked {\\n            uint256 l = (index + 1) % cardinality; // oldest observation\\n            uint256 r = l + cardinality - 1; // newest observation\\n            uint256 i;\\n            while (true) {\\n                i = (l + r) / 2;\\n\\n                beforeOrAt = self[i % cardinality];\\n\\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\\n                if (!beforeOrAt.initialized) {\\n                    l = i + 1;\\n                    continue;\\n                }\\n\\n                atOrAfter = self[(i + 1) % cardinality];\\n\\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\\n\\n                // check if we've found the answer!\\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\\n\\n                if (!targetAtOrAfter) r = i - 1;\\n                else l = i + 1;\\n            }\\n        }\\n    }\\n\\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\\n    /// @dev Assumes there is at least 1 initialized observation.\\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param target The timestamp at which the reserved observation should be for\\n    /// @param tick The active tick at the time of the returned or simulated observation\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The total pool liquidity at the time of the call\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\\n    function getSurroundingObservations(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 target,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\\n        unchecked {\\n            // optimistically set before to the newest observation\\n            beforeOrAt = self[index];\\n\\n            // if the target is chronologically at or after the newest observation, we can early return\\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\\n                if (beforeOrAt.blockTimestamp == target) {\\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\\n                    return (beforeOrAt, atOrAfter);\\n                } else {\\n                    // otherwise, we need to transform\\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\\n                }\\n            }\\n\\n            // now, set before to the oldest observation\\n            beforeOrAt = self[(index + 1) % cardinality];\\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\\n\\n            // ensure that the target is chronologically at or after the oldest observation\\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\\n\\n            // if we've reached this point, we have to binary search\\n            return binarySearch(self, time, target, index, cardinality);\\n        }\\n    }\\n\\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\\n    /// at exactly the timestamp between the two observations.\\n    /// @param self The stored oracle array\\n    /// @param time The current block timestamp\\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\\n    /// @param tick The current tick\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The current in-range pool liquidity\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\\n    function observeSingle(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32 secondsAgo,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\\n        unchecked {\\n            if (secondsAgo == 0) {\\n                Observation memory last = self[index];\\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\\n            }\\n\\n            uint32 target = time - secondsAgo;\\n\\n            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\\n                self,\\n                time,\\n                target,\\n                tick,\\n                index,\\n                liquidity,\\n                cardinality\\n            );\\n\\n            if (target == beforeOrAt.blockTimestamp) {\\n                // we're at the left boundary\\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\\n            } else if (target == atOrAfter.blockTimestamp) {\\n                // we're at the right boundary\\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\\n            } else {\\n                // we're in the middle\\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\\n                return (\\n                    beforeOrAt.tickCumulative +\\n                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\\n                        int56(uint56(targetDelta)),\\n                    beforeOrAt.secondsPerLiquidityCumulativeX128 +\\n                        uint160(\\n                            (uint256(\\n                                atOrAfter.secondsPerLiquidityCumulativeX128 -\\n                                    beforeOrAt.secondsPerLiquidityCumulativeX128\\n                            ) * targetDelta) / observationTimeDelta\\n                        )\\n                );\\n            }\\n        }\\n    }\\n\\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\n    /// @dev Reverts if `secondsAgos` > oldest observation\\n    /// @param self The stored oracle array\\n    /// @param time The current block.timestamp\\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\\n    /// @param tick The current tick\\n    /// @param index The index of the observation that was most recently written to the observations array\\n    /// @param liquidity The current in-range pool liquidity\\n    /// @param cardinality The number of populated elements in the oracle array\\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\\n    function observe(\\n        Observation[65535] storage self,\\n        uint32 time,\\n        uint32[] memory secondsAgos,\\n        int24 tick,\\n        uint16 index,\\n        uint128 liquidity,\\n        uint16 cardinality\\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\\n        unchecked {\\n            if (cardinality <= 0) revert I();\\n\\n            tickCumulatives = new int56[](secondsAgos.length);\\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\\n                    self,\\n                    time,\\n                    secondsAgos[i],\\n                    tick,\\n                    index,\\n                    liquidity,\\n                    cardinality\\n                );\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xa25b18af947c36b9add9e229c361beb6aba176fb435d7a24e6dc723cbc187442\",\"license\":\"BUSL-1.1\"},\"solidity/contracts/DataReceiver.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {OracleSidechain} from '../contracts/OracleSidechain.sol';\\nimport {Governable} from '../contracts/peripherals/Governable.sol';\\nimport {IDataReceiver, IOracleSidechain, IBridgeReceiverAdapter} from '../interfaces/IDataReceiver.sol';\\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\\n\\ncontract DataReceiver is IDataReceiver, Governable {\\n  IOracleFactory public oracleFactory;\\n\\n  bytes32 internal constant _ORACLE_INIT_CODE_HASH = 0x60676c7a3e0f9e5e5559983a5412ecaf2a461ea356358fe7d6ba3a8c3ab100f8;\\n\\n  mapping(IBridgeReceiverAdapter => bool) public whitelistedAdapters;\\n\\n  constructor(address _governance, IOracleFactory _oracleFactory) Governable(_governance) {\\n    oracleFactory = _oracleFactory;\\n  }\\n\\n  function _addObservations(IOracleSidechain _oracle, IOracleSidechain.ObservationData[] calldata _observationsData) internal {\\n    if (_oracle.write(_observationsData)) {\\n      emit ObservationsAdded(msg.sender, _observationsData);\\n    } else {\\n      revert ObservationsNotWritable();\\n    }\\n  }\\n\\n  function addObservations(\\n    IOracleSidechain.ObservationData[] calldata _observationsData,\\n    address _token0,\\n    address _token1,\\n    uint24 _fee\\n  ) external onlyWhitelistedAdapters {\\n    (address _tokenA, address _tokenB) = _token0 < _token1 ? (_token0, _token1) : (_token1, _token0);\\n\\n    IOracleSidechain _resultingAddress = IOracleSidechain(_calculateAddress(address(oracleFactory), _tokenA, _tokenB, _fee));\\n    bool _isDeployed = address(_resultingAddress).code.length > 0;\\n    if (_isDeployed) {\\n      return _addObservations(_resultingAddress, _observationsData);\\n    }\\n    address _deployedOracle = oracleFactory.deployOracle(_tokenA, _tokenB, _fee);\\n    _addObservations(IOracleSidechain(_deployedOracle), _observationsData);\\n  }\\n\\n  function _calculateAddress(\\n    address _factory,\\n    address _token0,\\n    address _token1,\\n    uint24 _fee\\n  ) internal pure returns (address _resultingAddress) {\\n    _resultingAddress = address(\\n      uint160(uint256(keccak256(abi.encodePacked(hex'ff', _factory, keccak256(abi.encode(_token0, _token1, _fee)), _ORACLE_INIT_CODE_HASH))))\\n    );\\n  }\\n\\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external onlyGovernance {\\n    _whitelistAdapter(_receiverAdapter, _isWhitelisted);\\n  }\\n\\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external onlyGovernance {\\n    uint256 _receiverAdapterLength = _receiverAdapters.length;\\n    if (_receiverAdapterLength != _isWhitelisted.length) revert LengthMismatch();\\n    uint256 _i;\\n    unchecked {\\n      for (_i; _i < _receiverAdapterLength; ++_i) {\\n        _whitelistAdapter(_receiverAdapters[_i], _isWhitelisted[_i]);\\n      }\\n    }\\n  }\\n\\n  function _whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) internal {\\n    whitelistedAdapters[_receiverAdapter] = _isWhitelisted;\\n    emit AdapterWhitelisted(_receiverAdapter, _isWhitelisted);\\n  }\\n\\n  modifier onlyWhitelistedAdapters() {\\n    if (!whitelistedAdapters[IBridgeReceiverAdapter(msg.sender)]) revert UnallowedAdapter();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x42de8d8f3c58e5c971273e4e497e32fa37b0c2d5750df4d4c945424aee2c16b8\",\"license\":\"Unlicense\"},\"solidity/contracts/OracleSidechain.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {Oracle} from '@uniswap/v3-core/contracts/libraries/Oracle.sol';\\nimport {IOracleSidechain} from '../interfaces/IOracleSidechain.sol';\\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\\nimport {IDataReceiver} from '../interfaces/IDataReceiver.sol';\\n\\n/// @title A sidechain oracle contract\\n/// @author 0xJabberwock (from DeFi Wonderland)\\n/// @notice Computes on-chain price data from Mainnet\\n/// @dev Bridges Uniswap V3 pool observations\\ncontract OracleSidechain is IOracleSidechain {\\n  using Oracle for Oracle.Observation[65535];\\n\\n  struct Slot0 {\\n    // the most-recently updated index of the observations array\\n    uint16 observationIndex;\\n    // the current maximum number of observations that are being stored\\n    uint16 observationCardinality;\\n    // the next maximum number of observations to store, triggered in observations.write\\n    uint16 observationCardinalityNext;\\n  }\\n  /// @inheritdoc IOracleSidechain\\n  Slot0 public slot0;\\n\\n  /// @inheritdoc IOracleSidechain\\n  IOracleFactory public immutable factory;\\n\\n  /// @inheritdoc IOracleSidechain\\n  Oracle.Observation[65535] public observations;\\n\\n  /// @inheritdoc IOracleSidechain\\n  int24 public lastTick;\\n\\n  address public immutable token0;\\n\\n  address public immutable token1;\\n\\n  uint24 public immutable fee;\\n\\n  constructor() {\\n    uint16 _cardinality;\\n    (factory, token0, token1, fee, _cardinality) = IOracleFactory(msg.sender).oracleParameters();\\n    slot0 = Slot0({observationIndex: _cardinality - 1, observationCardinality: _cardinality, observationCardinalityNext: _cardinality});\\n  }\\n\\n  /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\\n  function _getBlockTimestamp() internal view virtual returns (uint32) {\\n    return uint32(block.timestamp); // truncation is desired\\n  }\\n\\n  /// @inheritdoc IOracleSidechain\\n  function observe(uint32[] calldata _secondsAgos)\\n    external\\n    view\\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s)\\n  {\\n    return observations.observe(_getBlockTimestamp(), _secondsAgos, lastTick, slot0.observationIndex, 0, slot0.observationCardinality);\\n  }\\n\\n  /// @inheritdoc IOracleSidechain\\n  function write(ObservationData[] calldata _observationsData) external returns (bool _written) {\\n    if (IDataReceiver(msg.sender) != factory.dataReceiver()) revert OnlyDataReceiver();\\n    Oracle.Observation memory _lastObservation = observations[slot0.observationIndex];\\n    uint256 _observationsDataLength = _observationsData.length;\\n    for (uint256 _i; _i < _observationsDataLength; ++_i) {\\n      if (_lastObservation.blockTimestamp < _observationsData[_i].blockTimestamp) {\\n        _write(_observationsData[_i]);\\n        _written = true;\\n      }\\n    }\\n  }\\n\\n  function _write(ObservationData calldata _observationData) private {\\n    (uint16 _indexUpdated, uint16 _cardinalityUpdated) = observations.write(\\n      slot0.observationIndex,\\n      _observationData.blockTimestamp,\\n      lastTick,\\n      0,\\n      slot0.observationCardinality,\\n      slot0.observationCardinalityNext\\n    );\\n    (slot0.observationIndex, slot0.observationCardinality) = (_indexUpdated, _cardinalityUpdated);\\n    lastTick = _observationData.tick;\\n    emit ObservationWritten(msg.sender, _observationData);\\n  }\\n}\\n\",\"keccak256\":\"0xbd5c253cfb21b990718bd33670f7de169561bb8a2999f20c10ca221b3c5ca93b\",\"license\":\"Unlicense\"},\"solidity/contracts/peripherals/Governable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IGovernable} from '../../interfaces/peripherals/IGovernable.sol';\\n\\nabstract contract Governable is IGovernable {\\n  /// @inheritdoc IGovernable\\n  address public governance;\\n\\n  /// @inheritdoc IGovernable\\n  address public pendingGovernance;\\n\\n  constructor(address _governance) {\\n    if (_governance == address(0)) revert NoGovernanceZeroAddress();\\n    governance = _governance;\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function setGovernance(address _governance) external onlyGovernance {\\n    pendingGovernance = _governance;\\n    emit GovernanceProposal(_governance);\\n  }\\n\\n  /// @inheritdoc IGovernable\\n  function acceptGovernance() external onlyPendingGovernance {\\n    governance = pendingGovernance;\\n    delete pendingGovernance;\\n    emit GovernanceSet(governance);\\n  }\\n\\n  /// @notice Functions with this modifier can only be called by governance\\n  modifier onlyGovernance() {\\n    if (msg.sender != governance) revert OnlyGovernance();\\n    _;\\n  }\\n\\n  /// @notice Functions with this modifier can only be called by pendingGovernance\\n  modifier onlyPendingGovernance() {\\n    if (msg.sender != pendingGovernance) revert OnlyPendingGovernance();\\n    _;\\n  }\\n}\\n\",\"keccak256\":\"0x396fadbc0c0ce9100bb74db15d421d43883c06753a0a8ca78c2f1ee685c3fb6c\",\"license\":\"MIT\"},\"solidity/interfaces/IDataReceiver.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\\nimport {IOracleSidechain} from '../interfaces/IOracleSidechain.sol';\\nimport {IBridgeReceiverAdapter} from '../interfaces/bridges/IBridgeReceiverAdapter.sol';\\nimport {IGovernable} from '../interfaces/peripherals/IGovernable.sol';\\n\\n/// @title The DataReceiver interface\\n/// @author 0xJabberwock (from DeFi Wonderland)\\n/// @notice Contains state variables, events, custom errors and functions used in DataReceiver\\ninterface IDataReceiver is IGovernable {\\n  // STATE VARIABLES\\n  function oracleFactory() external view returns (IOracleFactory _oracleFactory);\\n\\n  function whitelistedAdapters(IBridgeReceiverAdapter _adapter) external view returns (bool _isAllowed);\\n\\n  // EVENTS\\n\\n  event ObservationsAdded(address _user, IOracleSidechain.ObservationData[] _observationsData);\\n  event AdapterWhitelisted(IBridgeReceiverAdapter _adapter, bool _isAllowed);\\n\\n  // CUSTOM ERRORS\\n\\n  error ObservationsNotWritable();\\n  error UnallowedAdapter();\\n  error LengthMismatch();\\n\\n  // FUNCTIONS\\n\\n  function addObservations(\\n    IOracleSidechain.ObservationData[] calldata _observationsData,\\n    address _token0,\\n    address _token1,\\n    uint24 _fee\\n  ) external;\\n\\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external;\\n\\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external;\\n}\\n\",\"keccak256\":\"0xbf307127a9713230185216d5f945ec74556e3aa032ed9f60ea393fa803640e80\",\"license\":\"Unlicense\"},\"solidity/interfaces/IOracleFactory.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IOracleSidechain} from '../interfaces/IOracleSidechain.sol';\\nimport {IDataReceiver} from '../interfaces/IDataReceiver.sol';\\nimport {IGovernable} from '../interfaces/peripherals/IGovernable.sol';\\n\\ninterface IOracleFactory is IGovernable {\\n  // STRUCTS\\n\\n  struct OracleParameters {\\n    IOracleFactory factory;\\n    address token0;\\n    address token1;\\n    uint24 fee;\\n    uint16 cardinality;\\n  }\\n\\n  // STATE VARIABLES\\n\\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\\n\\n  function initialCardinality() external view returns (uint16 _initialCardinality);\\n\\n  function oracleParameters()\\n    external\\n    view\\n    returns (\\n      IOracleFactory _factory,\\n      address _token0,\\n      address _token1,\\n      uint24 _fee,\\n      uint16 _cardinality\\n    );\\n\\n  // EVENTS\\n\\n  event OracleDeployed(address _oracleAddress, address _token0, address _token1, uint24 _fee, uint16 _cardinality);\\n  event DataReceiverSet(IDataReceiver _dataReceiver);\\n  event InitialCardinalitySet(uint16 _initialCardinality);\\n\\n  // CUSTOM ERRORS\\n\\n  error OnlyDataReceiver();\\n\\n  // FUNCTIONS\\n\\n  function deployOracle(\\n    address _token0,\\n    address _token1,\\n    uint24 _fee\\n  ) external returns (address _deployedOracle);\\n\\n  function setDataReceiver(IDataReceiver _dataReceiver) external;\\n\\n  function setInitialCardinality(uint16 _initialCardinality) external;\\n}\\n\",\"keccak256\":\"0x1e194db29b22cf193cc9c369750687f4a551bd53aa9a4580d5290c23961ee4c8\",\"license\":\"Unlicense\"},\"solidity/interfaces/IOracleSidechain.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\\n\\n/// @title The OracleSidechain interface\\n/// @author 0xJabberwock (from DeFi Wonderland)\\n/// @notice Contains state variables, events, custom errors and functions used in OracleSidechain\\ninterface IOracleSidechain {\\n  // STRUCTS\\n\\n  struct ObservationData {\\n    uint32 blockTimestamp;\\n    int24 tick;\\n  }\\n\\n  // STATE VARIABLES\\n\\n  // TODO: complete natspec\\n\\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\\n  /// when accessed externally.\\n  /// @return _observationIndex The index of the last oracle observation that was written,\\n  /// @return _observationCardinality The current maximum number of observations stored in the pool,\\n  /// @return _observationCardinalityNext The next maximum number of observations, to be updated when the observation.\\n  function slot0()\\n    external\\n    view\\n    returns (\\n      uint16 _observationIndex,\\n      uint16 _observationCardinality,\\n      uint16 _observationCardinalityNext\\n    );\\n\\n  function lastTick() external view returns (int24 _lastTick);\\n\\n  function factory() external view returns (IOracleFactory _oracleFactory);\\n\\n  function token0() external view returns (address _token0);\\n\\n  function token1() external view returns (address _token1);\\n\\n  /// @notice Returns data about a specific observation index\\n  /// @param _index The element of the observations array to fetch\\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\n  /// ago, rather than at a specific index in the array.\\n  /// @return _blockTimestamp The timestamp of the observation,\\n  /// @return _tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\n  /// @return _secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\\n  /// @return _initialized whether the observation has been initialized and the values are safe to use\\n  function observations(uint256 _index)\\n    external\\n    view\\n    returns (\\n      uint32 _blockTimestamp,\\n      int56 _tickCumulative,\\n      uint160 _secondsPerLiquidityCumulativeX128,\\n      bool _initialized\\n    );\\n\\n  // EVENTS;\\n\\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\n  /// just before a mint/swap/burn.\\n  /// @param _observationCardinalityNextOld The previous value of the next observation cardinality\\n  /// @param _observationCardinalityNextNew The updated value of the next observation cardinality\\n  event IncreaseObservationCardinalityNext(uint16 _observationCardinalityNextOld, uint16 _observationCardinalityNextNew);\\n\\n  event ObservationWritten(address _user, ObservationData _observationData);\\n\\n  // CUSTOM ERRORS\\n\\n  error AI();\\n  error OnlyDataReceiver();\\n\\n  // FUNCTIONS\\n\\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n  /// you must call it with secondsAgos = [3600, 0].\\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n  /// @param _secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n  /// @return _tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n  /// @return _secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\\n  /// timestamp\\n  function observe(uint32[] calldata _secondsAgos)\\n    external\\n    view\\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s);\\n\\n  function write(ObservationData[] calldata _observationsData) external returns (bool _written);\\n}\\n\",\"keccak256\":\"0x320fcd13db7cb9f4136967b5e906db257d1885267127f09905c96da6222e1d92\",\"license\":\"Unlicense\"},\"solidity/interfaces/bridges/IBridgeReceiverAdapter.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity >=0.8.8 <0.9.0;\\n\\nimport {IOracleSidechain} from '../../interfaces/IOracleSidechain.sol';\\n\\ninterface IBridgeReceiverAdapter {\\n  // FUNCTIONS\\n\\n  function addObservations(\\n    IOracleSidechain.ObservationData[] calldata _observationsData,\\n    address _token0,\\n    address _token1,\\n    uint24 _fee\\n  ) external;\\n}\\n\",\"keccak256\":\"0x4311156f68175babab1ef7d19caa7bf08c66edb4d115244ccf4883bdfebb11ed\",\"license\":\"Unlicense\"},\"solidity/interfaces/peripherals/IGovernable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >=0.8.8 <0.9.0;\\n\\n/// @title Governable contract\\n/// @notice Manages the governance role\\ninterface IGovernable {\\n  // Events\\n\\n  /// @notice Emitted when pendingGovernance accepts to be governance\\n  /// @param _governance Address of the new governance\\n  event GovernanceSet(address _governance);\\n\\n  /// @notice Emitted when a new governance is proposed\\n  /// @param _pendingGovernance Address that is proposed to be the new governance\\n  event GovernanceProposal(address _pendingGovernance);\\n\\n  // Errors\\n\\n  /// @notice Throws if the caller of the function is not governance\\n  error OnlyGovernance();\\n\\n  /// @notice Throws if the caller of the function is not pendingGovernance\\n  error OnlyPendingGovernance();\\n\\n  /// @notice Throws if trying to set governance to zero address\\n  error NoGovernanceZeroAddress();\\n\\n  // Variables\\n\\n  /// @notice Stores the governance address\\n  /// @return _governance The governance addresss\\n  function governance() external view returns (address _governance);\\n\\n  /// @notice Stores the pendingGovernance address\\n  /// @return _pendingGovernance The pendingGovernance addresss\\n  function pendingGovernance() external view returns (address _pendingGovernance);\\n\\n  // Methods\\n\\n  /// @notice Proposes a new address to be governance\\n  /// @param _governance The address being proposed as the new governance\\n  function setGovernance(address _governance) external;\\n\\n  /// @notice Changes the governance from the current governance to the previously proposed address\\n  function acceptGovernance() external;\\n}\\n\",\"keccak256\":\"0xf7e6dc04662fb90751f546440cfe3bcf0cd5e854daba774790b872c0566a2930\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50604051610ae3380380610ae383398101604081905261002f916100a3565b816001600160a01b0381166100565760405162b293ed60e81b815260040160405180910390fd5b600080546001600160a01b039283166001600160a01b03199182161790915560028054939092169216919091179055506100dd565b6001600160a01b03811681146100a057600080fd5b50565b600080604083850312156100b657600080fd5b82516100c18161008b565b60208401519092506100d28161008b565b809150509250929050565b6109f7806100ec6000396000f3fe608060405234801561001057600080fd5b50600436106100935760003560e01c8063ab033ea911610066578063ab033ea9146100f8578063b893cce21461010b578063c7f7fb901461013e578063f39c38a014610151578063f854c7c21461016457600080fd5b80630ddb5dd214610098578063238efcbc146100ad5780635aa6e675146100b5578063954e863e146100e5575b600080fd5b6100ab6100a63660046106ff565b610177565b005b6100ab610237565b6000546100c8906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100ab6100f3366004610791565b6102c0565b6100ab6101063660046107ca565b6102f9565b61012e6101193660046107ca565b60036020526000908152604090205460ff1681565b60405190151581526020016100dc565b6002546100c8906001600160a01b031681565b6001546100c8906001600160a01b031681565b6100ab6101723660046107ee565b610378565b6000546001600160a01b031633146101a2576040516354348f0360e01b815260040160405180910390fd5b828181146101c6576040516001621398b960e31b0319815260040160405180910390fd5b60005b8181101561022f576102278686838181106101e6576101e66108a2565b90506020020160208101906101fb91906107ca565b85858481811061020d5761020d6108a2565b905060200201602081019061022291906108b8565b6104b5565b6001016101c9565b505050505050565b6001546001600160a01b0316331461026257604051637ef5703160e11b815260040160405180910390fd5b60018054600080546001600160a01b0383166001600160a01b031991821681179092559091169091556040519081527fc73be659241aade67e9a059bcf21494955018b213dbd1179054ccf928b13f3b69060200160405180910390a1565b6000546001600160a01b031633146102eb576040516354348f0360e01b815260040160405180910390fd5b6102f582826104b5565b5050565b6000546001600160a01b03163314610324576040516354348f0360e01b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b0383169081179091556040519081527fe987aaedf9d279143bdf1eee16cf1d0feb47742867d81083df8d6cd0a5ac857f9060200160405180910390a150565b3360009081526003602052604090205460ff166103a8576040516360ece74160e01b815260040160405180910390fd5b600080836001600160a01b0316856001600160a01b0316106103cb5783856103ce565b84845b60025491935091506000906103ee906001600160a01b0316848487610518565b90506001600160a01b0381163b158015906104175761040e828a8a6105e4565b505050506104ae565b60025460405163e0fee1f560e01b81526001600160a01b038681166004830152858116602483015262ffffff88166044830152600092169063e0fee1f5906064016020604051808303816000875af1158015610477573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061049b91906108d5565b90506104a8818b8b6105e4565b50505050505b5050505050565b6001600160a01b038216600081815260036020908152604091829020805460ff19168515159081179091558251938452908301527f3cece36ac6216147f57b10bb30975f82b18b8b290a7925c322277e684afcce4a910160405180910390a15050565b604080516001600160a01b03808616602083015284169181019190915262ffffff82166060820152600090859060800160408051601f198184030181529082905280516020918201206105c3939290917f60676c7a3e0f9e5e5559983a5412ecaf2a461ea356358fe7d6ba3a8c3ab100f891016001600160f81b0319815260609390931b6bffffffffffffffffffffffff191660018401526015830191909152603582015260550190565b60408051601f19818403018152919052805160209091012095945050505050565b604051633870176560e01b81526001600160a01b03841690633870176590610612908590859060040161095a565b6020604051808303816000875af1158015610631573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106559190610976565b1561069a577f617afa62635b4d3e0901427201c347a24650276db5c920f7347d6d969bf2567433838360405161068d93929190610993565b60405180910390a1505050565b604051630a96dcbd60e11b815260040160405180910390fd5b60008083601f8401126106c557600080fd5b50813567ffffffffffffffff8111156106dd57600080fd5b6020830191508360208260051b85010111156106f857600080fd5b9250929050565b6000806000806040858703121561071557600080fd5b843567ffffffffffffffff8082111561072d57600080fd5b610739888389016106b3565b9096509450602087013591508082111561075257600080fd5b5061075f878288016106b3565b95989497509550505050565b6001600160a01b038116811461078057600080fd5b50565b801515811461078057600080fd5b600080604083850312156107a457600080fd5b82356107af8161076b565b915060208301356107bf81610783565b809150509250929050565b6000602082840312156107dc57600080fd5b81356107e78161076b565b9392505050565b60008060008060006080868803121561080657600080fd5b853567ffffffffffffffff8082111561081e57600080fd5b818801915088601f83011261083257600080fd5b81358181111561084157600080fd5b8960208260061b850101111561085657600080fd5b6020928301975095505086013561086c8161076b565b9250604086013561087c8161076b565b9150606086013562ffffff8116811461089457600080fd5b809150509295509295909350565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156108ca57600080fd5b81356107e781610783565b6000602082840312156108e757600080fd5b81516107e78161076b565b8183526000602080850194508260005b8581101561094f57813563ffffffff811680821461091f57600080fd5b88525081830135600281900b80821461093757600080fd5b88850152506040968701969190910190600101610902565b509495945050505050565b60208152600061096e6020830184866108f2565b949350505050565b60006020828403121561098857600080fd5b81516107e781610783565b6001600160a01b03841681526040602082018190526000906109b890830184866108f2565b9594505050505056fea26469706673582212200f73d220209a655fc278a27f39e1c654bc2e78ca20dc1b132c85990465706c5664736f6c634300080f0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100935760003560e01c8063ab033ea911610066578063ab033ea9146100f8578063b893cce21461010b578063c7f7fb901461013e578063f39c38a014610151578063f854c7c21461016457600080fd5b80630ddb5dd214610098578063238efcbc146100ad5780635aa6e675146100b5578063954e863e146100e5575b600080fd5b6100ab6100a63660046106ff565b610177565b005b6100ab610237565b6000546100c8906001600160a01b031681565b6040516001600160a01b0390911681526020015b60405180910390f35b6100ab6100f3366004610791565b6102c0565b6100ab6101063660046107ca565b6102f9565b61012e6101193660046107ca565b60036020526000908152604090205460ff1681565b60405190151581526020016100dc565b6002546100c8906001600160a01b031681565b6001546100c8906001600160a01b031681565b6100ab6101723660046107ee565b610378565b6000546001600160a01b031633146101a2576040516354348f0360e01b815260040160405180910390fd5b828181146101c6576040516001621398b960e31b0319815260040160405180910390fd5b60005b8181101561022f576102278686838181106101e6576101e66108a2565b90506020020160208101906101fb91906107ca565b85858481811061020d5761020d6108a2565b905060200201602081019061022291906108b8565b6104b5565b6001016101c9565b505050505050565b6001546001600160a01b0316331461026257604051637ef5703160e11b815260040160405180910390fd5b60018054600080546001600160a01b0383166001600160a01b031991821681179092559091169091556040519081527fc73be659241aade67e9a059bcf21494955018b213dbd1179054ccf928b13f3b69060200160405180910390a1565b6000546001600160a01b031633146102eb576040516354348f0360e01b815260040160405180910390fd5b6102f582826104b5565b5050565b6000546001600160a01b03163314610324576040516354348f0360e01b815260040160405180910390fd5b600180546001600160a01b0319166001600160a01b0383169081179091556040519081527fe987aaedf9d279143bdf1eee16cf1d0feb47742867d81083df8d6cd0a5ac857f9060200160405180910390a150565b3360009081526003602052604090205460ff166103a8576040516360ece74160e01b815260040160405180910390fd5b600080836001600160a01b0316856001600160a01b0316106103cb5783856103ce565b84845b60025491935091506000906103ee906001600160a01b0316848487610518565b90506001600160a01b0381163b158015906104175761040e828a8a6105e4565b505050506104ae565b60025460405163e0fee1f560e01b81526001600160a01b038681166004830152858116602483015262ffffff88166044830152600092169063e0fee1f5906064016020604051808303816000875af1158015610477573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061049b91906108d5565b90506104a8818b8b6105e4565b50505050505b5050505050565b6001600160a01b038216600081815260036020908152604091829020805460ff19168515159081179091558251938452908301527f3cece36ac6216147f57b10bb30975f82b18b8b290a7925c322277e684afcce4a910160405180910390a15050565b604080516001600160a01b03808616602083015284169181019190915262ffffff82166060820152600090859060800160408051601f198184030181529082905280516020918201206105c3939290917f60676c7a3e0f9e5e5559983a5412ecaf2a461ea356358fe7d6ba3a8c3ab100f891016001600160f81b0319815260609390931b6bffffffffffffffffffffffff191660018401526015830191909152603582015260550190565b60408051601f19818403018152919052805160209091012095945050505050565b604051633870176560e01b81526001600160a01b03841690633870176590610612908590859060040161095a565b6020604051808303816000875af1158015610631573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106559190610976565b1561069a577f617afa62635b4d3e0901427201c347a24650276db5c920f7347d6d969bf2567433838360405161068d93929190610993565b60405180910390a1505050565b604051630a96dcbd60e11b815260040160405180910390fd5b60008083601f8401126106c557600080fd5b50813567ffffffffffffffff8111156106dd57600080fd5b6020830191508360208260051b85010111156106f857600080fd5b9250929050565b6000806000806040858703121561071557600080fd5b843567ffffffffffffffff8082111561072d57600080fd5b610739888389016106b3565b9096509450602087013591508082111561075257600080fd5b5061075f878288016106b3565b95989497509550505050565b6001600160a01b038116811461078057600080fd5b50565b801515811461078057600080fd5b600080604083850312156107a457600080fd5b82356107af8161076b565b915060208301356107bf81610783565b809150509250929050565b6000602082840312156107dc57600080fd5b81356107e78161076b565b9392505050565b60008060008060006080868803121561080657600080fd5b853567ffffffffffffffff8082111561081e57600080fd5b818801915088601f83011261083257600080fd5b81358181111561084157600080fd5b8960208260061b850101111561085657600080fd5b6020928301975095505086013561086c8161076b565b9250604086013561087c8161076b565b9150606086013562ffffff8116811461089457600080fd5b809150509295509295909350565b634e487b7160e01b600052603260045260246000fd5b6000602082840312156108ca57600080fd5b81356107e781610783565b6000602082840312156108e757600080fd5b81516107e78161076b565b8183526000602080850194508260005b8581101561094f57813563ffffffff811680821461091f57600080fd5b88525081830135600281900b80821461093757600080fd5b88850152506040968701969190910190600101610902565b509495945050505050565b60208152600061096e6020830184866108f2565b949350505050565b60006020828403121561098857600080fd5b81516107e781610783565b6001600160a01b03841681526040602082018190526000906109b890830184866108f2565b9594505050505056fea26469706673582212200f73d220209a655fc278a27f39e1c654bc2e78ca20dc1b132c85990465706c5664736f6c634300080f0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "setGovernance(address)": {
        "params": {
          "_governance": "The address being proposed as the new governance"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "errors": {
      "NoGovernanceZeroAddress()": [
        {
          "notice": "Throws if trying to set governance to zero address"
        }
      ],
      "OnlyGovernance()": [
        {
          "notice": "Throws if the caller of the function is not governance"
        }
      ],
      "OnlyPendingGovernance()": [
        {
          "notice": "Throws if the caller of the function is not pendingGovernance"
        }
      ]
    },
    "events": {
      "GovernanceProposal(address)": {
        "notice": "Emitted when a new governance is proposed"
      },
      "GovernanceSet(address)": {
        "notice": "Emitted when pendingGovernance accepts to be governance"
      }
    },
    "kind": "user",
    "methods": {
      "acceptGovernance()": {
        "notice": "Changes the governance from the current governance to the previously proposed address"
      },
      "governance()": {
        "notice": "Stores the governance address"
      },
      "pendingGovernance()": {
        "notice": "Stores the pendingGovernance address"
      },
      "setGovernance(address)": {
        "notice": "Proposes a new address to be governance"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 20231,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "governance",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 20234,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "pendingGovernance",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 18683,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "oracleFactory",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(IOracleFactory)20705"
      },
      {
        "astId": 18691,
        "contract": "solidity/contracts/DataReceiver.sol:DataReceiver",
        "label": "whitelistedAdapters",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_contract(IBridgeReceiverAdapter)20819,t_bool)"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(IBridgeReceiverAdapter)20819": {
        "encoding": "inplace",
        "label": "contract IBridgeReceiverAdapter",
        "numberOfBytes": "20"
      },
      "t_contract(IOracleFactory)20705": {
        "encoding": "inplace",
        "label": "contract IOracleFactory",
        "numberOfBytes": "20"
      },
      "t_mapping(t_contract(IBridgeReceiverAdapter)20819,t_bool)": {
        "encoding": "mapping",
        "key": "t_contract(IBridgeReceiverAdapter)20819",
        "label": "mapping(contract IBridgeReceiverAdapter => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}