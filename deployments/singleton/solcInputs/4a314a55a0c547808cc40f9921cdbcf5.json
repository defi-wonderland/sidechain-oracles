{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/bridges/ConnextReceiverAdapter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IXReceiver} from '@connext/nxtp-contracts/contracts/core/connext/interfaces/IXReceiver.sol';\nimport {IConnextReceiverAdapter, IDataReceiver, IOracleSidechain} from '../../interfaces/bridges/IConnextReceiverAdapter.sol';\n\ncontract ConnextReceiverAdapter is IXReceiver, IConnextReceiverAdapter {\n  /// @inheritdoc IConnextReceiverAdapter\n  IDataReceiver public immutable dataReceiver;\n\n  // The connectHandler contract on this domain\n  address public connext;\n  // The origin domain ID\n  uint32 public immutable origin;\n  // The DAO that's expected as the xcaller\n  address public immutable dao;\n\n  constructor(\n    IDataReceiver _dataReceiver,\n    address _dao,\n    uint32 _origin,\n    address _connext\n  ) {\n    dataReceiver = _dataReceiver;\n    dao = _dao;\n    origin = _origin;\n    connext = address(_connext);\n  }\n\n  // TODO: move to common Adapter contract\n  function _addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) internal {\n    dataReceiver.addObservations(_observationsData, _poolSalt, _poolNonce);\n    emit DataSent(_observationsData, _poolSalt); // TODO: review event emission\n  }\n\n  modifier onlyExecutor(address _originSender, uint32 _origin) {\n    if (\n      msg.sender != connext ||\n      _originSender != dao ||\n      _origin != origin\n    ) revert UnauthorizedCaller();\n    _;\n  }\n\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external onlyExecutor(_originSender, _origin) returns (bytes memory) {\n    (IOracleSidechain.ObservationData[] memory _observationsData, bytes32 _poolSalt, uint24 _poolNonce) = abi.decode(\n      _callData,\n      (IOracleSidechain.ObservationData[], bytes32, uint24)\n    );\n\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\n    return bytes(abi.encode('random'));\n  }\n}\n"
    },
    "solidity/interfaces/bridges/IConnextReceiverAdapter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IBridgeReceiverAdapter, IOracleSidechain} from './IBridgeReceiverAdapter.sol';\nimport {IDataReceiver} from '../IDataReceiver.sol';\n\ninterface IConnextReceiverAdapter is IBridgeReceiverAdapter {\n  // STATE VARIABLES\n\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\n\n  function dao() external view returns (address _originContract);\n\n  function origin() external view returns (uint32 _originDomain);\n\n  // connext()\n}\n"
    },
    "@connext/nxtp-contracts/contracts/core/connext/interfaces/IXReceiver.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.15;\n\ninterface IXReceiver {\n  function xReceive(\n    bytes32 _transferId,\n    uint256 _amount,\n    address _asset,\n    address _originSender,\n    uint32 _origin,\n    bytes memory _callData\n  ) external returns (bytes memory);\n}\n"
    },
    "solidity/interfaces/bridges/IBridgeReceiverAdapter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleSidechain} from '../IOracleSidechain.sol';\n\ninterface IBridgeReceiverAdapter {\n  // FUNCTIONS\n\n  /* NOTE: callback methods should be here declared */\n\n  // EVENTS\n\n  event DataSent(IOracleSidechain.ObservationData[] _observationsData, bytes32 _poolSalt);\n\n  // ERRORS\n\n  error UnauthorizedCaller();\n}\n"
    },
    "solidity/interfaces/IDataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleFactory} from './IOracleFactory.sol';\nimport {IOracleSidechain} from './IOracleSidechain.sol';\nimport {IBridgeReceiverAdapter} from './bridges/IBridgeReceiverAdapter.sol';\nimport {IGovernable} from './peripherals/IGovernable.sol';\n\n/// @title The DataReceiver interface\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Contains state variables, events, custom errors and functions used in DataReceiver\ninterface IDataReceiver is IGovernable {\n  // STATE VARIABLES\n\n  function oracleFactory() external view returns (IOracleFactory _oracleFactory);\n\n  //solhint-disable-next-line func-name-mixedcase\n  function ORACLE_INIT_CODE_HASH() external view returns (bytes32 _oracleInitCodeHash);\n\n  function whitelistedAdapters(IBridgeReceiverAdapter _adapter) external view returns (bool _isAllowed);\n\n  // EVENTS\n\n  event ObservationsAdded(address _user, IOracleSidechain.ObservationData[] _observationsData);\n\n  event AdapterWhitelisted(IBridgeReceiverAdapter _adapter, bool _isAllowed);\n\n  // ERRORS\n\n  error ObservationsNotWritable();\n\n  error UnallowedAdapter();\n\n  error LengthMismatch();\n\n  // FUNCTIONS\n\n  function addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external;\n\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external;\n\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external;\n}\n"
    },
    "solidity/interfaces/IOracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleFactory} from './IOracleFactory.sol';\n\n/// @title The OracleSidechain interface\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Contains state variables, events, custom errors and functions used in OracleSidechain\ninterface IOracleSidechain {\n  // STRUCTS\n\n  struct ObservationData {\n    uint32 blockTimestamp;\n    int24 tick;\n  }\n\n  // STATE VARIABLES\n\n  // TODO: complete natspec\n\n  function factory() external view returns (IOracleFactory _oracleFactory);\n\n  function token0() external view returns (address _token0);\n\n  function token1() external view returns (address _token1);\n\n  function fee() external view returns (uint24 _fee);\n\n  function poolSalt() external view returns (bytes32 _poolSalt);\n\n  function poolNonce() external view returns (uint24 _poolNonce);\n\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return _sqrtPriceX96 Used to maintain compatibility with Uniswap V3\n  /// @return _tick Used to maintain compatibility with Uniswap V3\n  /// @return _observationIndex The index of the last oracle observation that was written,\n  /// @return _observationCardinality The current maximum number of observations stored in the pool,\n  /// @return _observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// @return _feeProtocol Used to maintain compatibility with Uniswap V3\n  /// @return _unlocked Used to maintain compatibility with Uniswap V3\n  function slot0()\n    external\n    view\n    returns (\n      uint160 _sqrtPriceX96,\n      int24 _tick,\n      uint16 _observationIndex,\n      uint16 _observationCardinality,\n      uint16 _observationCardinalityNext,\n      uint8 _feeProtocol,\n      bool _unlocked\n    );\n\n  /// @notice Returns data about a specific observation index\n  /// @param _index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return _blockTimestamp The timestamp of the observation,\n  /// @return _tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// @return _secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// @return _initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 _index)\n    external\n    view\n    returns (\n      uint32 _blockTimestamp,\n      int56 _tickCumulative,\n      uint160 _secondsPerLiquidityCumulativeX128,\n      bool _initialized\n    );\n\n  // EVENTS\n\n  event PoolInfoInitialized(bytes32 _poolSalt, address _token0, address _token1, uint24 _fee);\n  event ObservationWritten(address _user, ObservationData _observationData);\n\n  // ERRORS\n\n  error AI();\n  error InvalidPool();\n  error OnlyDataReceiver();\n\n  // FUNCTIONS\n\n  function initializePoolInfo(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external;\n\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param _secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return _tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return _secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata _secondsAgos)\n    external\n    view\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s);\n\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external returns (bool _written);\n}\n"
    },
    "solidity/interfaces/IOracleFactory.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleSidechain} from './IOracleSidechain.sol';\nimport {IDataReceiver} from './IDataReceiver.sol';\nimport {IGovernable} from './peripherals/IGovernable.sol';\n\ninterface IOracleFactory is IGovernable {\n  // STRUCTS\n\n  struct OracleParameters {\n    IOracleFactory factory;\n    bytes32 poolSalt;\n    uint24 poolNonce;\n    uint16 cardinality;\n  }\n\n  // STATE VARIABLES\n\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\n\n  /// @return _factory The address of the deployer factory\n  /// @return _poolSalt The id of both the oracle and the pool\n  /// @return _poolNonce The initial nonce of the pool data\n  /// @return _cardinality The size of the observations memory storage\n  function oracleParameters()\n    external\n    view\n    returns (\n      IOracleFactory _factory,\n      bytes32 _poolSalt,\n      uint24 _poolNonce,\n      uint16 _cardinality\n    );\n\n  /// @return _initialCardinality The initial size of the observations memory storage for newly deployed pools\n  function initialCardinality() external view returns (uint16 _initialCardinality);\n\n  // EVENTS\n\n  event OracleDeployed(address _oracle, bytes32 _poolSalt, uint16 _cardinality);\n  event DataReceiverSet(IDataReceiver _dataReceiver);\n\n  event InitialCardinalitySet(uint16 _initialCardinality);\n\n  // ERRORS\n\n  error OnlyDataReceiver();\n\n  // VIEWS\n\n  /// @notice Overrides UniV3Factory getPool mapping\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  /// @return _oracle The oracle address\n  function getPool(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external view returns (address _oracle);\n\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  /// @return _poolSalt Pool salt for inquired parameters\n  function getPoolSalt(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external view returns (bytes32 _poolSalt);\n\n  // FUNCTIONS\n\n  /// @notice Deploys a new oracle given an inputted salt\n  /// @dev Requires that the salt has not been deployed before\n  /// @param _poolSalt Pool salt that deterministically binds an oracle with a pool\n  /// @return _deployedOracle The address of the newly deployed oracle\n  function deployOracle(bytes32 _poolSalt, uint24 _poolNonce) external returns (address _deployedOracle);\n\n  /// @notice Allows governor to set a new allowed dataReceiver\n  /// @dev Will disallow the previous dataReceiver\n  /// @param _dataReceiver The address of the new allowed dataReceiver\n  function setDataReceiver(IDataReceiver _dataReceiver) external;\n\n  /// @notice Allows governor to set a new initial cardinality for new oracles\n  /// @param _initialCardinality The initial size of the observations memory storage for newly deployed pools\n  function setInitialCardinality(uint16 _initialCardinality) external;\n}\n"
    },
    "solidity/interfaces/peripherals/IGovernable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\ninterface IGovernable {\n  // STATE VARIABLES\n\n  /// @return _governor Address of the current governor\n  function governor() external view returns (address _governor);\n\n  /// @return _pendingGovernor Address of the current pending governor\n  function pendingGovernor() external view returns (address _pendingGovernor);\n\n  // EVENTS\n\n  /// @notice Emitted when a new pending governor is set\n  /// @param _governor Address of the current governor\n  /// @param _pendingGovernor Address of the proposed next governor\n  event PendingGovernorSet(address _governor, address _pendingGovernor);\n\n  /// @notice Emitted when a new governor is set\n  /// @param _newGovernor Address of the new governor\n  event PendingGovernorAccepted(address _newGovernor);\n\n  // ERRORS\n\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if a non-governor user tries to call a OnlyGovernor function\n  error OnlyGovernor();\n\n  /// @notice Throws if a non-pending-governor user tries to call a OnlyPendingGovernor function\n  error OnlyPendingGovernor();\n\n  // FUNCTIONS\n\n  /// @notice Allows a governor to propose a new governor\n  /// @param _pendingGovernor Address of the proposed new governor\n  function setPendingGovernor(address _pendingGovernor) external;\n\n  /// @notice Allows a proposed governor to accept the governance\n  function acceptPendingGovernor() external;\n}\n"
    },
    "solidity/for-test/ConnextReceiverAdapterForTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {ConnextReceiverAdapter, IDataReceiver, IOracleSidechain} from '../contracts/bridges/ConnextReceiverAdapter.sol';\n\ncontract ConnextReceiverAdapterForTest is ConnextReceiverAdapter {\n  constructor(\n    IDataReceiver _dataReceiver,\n    address _originContract,\n    uint32 _originDomain,\n    address _connext\n  ) ConnextReceiverAdapter(_dataReceiver, _originContract, _originDomain, _connext) {}\n\n  function internalAddObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external {\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}