{
  "language": "Solidity",
  "sources": {
    "solidity/for-test/DataReceiverForTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {DataReceiver} from '../contracts/DataReceiver.sol';\nimport {OracleSidechain} from '../contracts/OracleSidechain.sol';\nimport {IDataReceiver, IOracleSidechain, IBridgeReceiverAdapter} from '../interfaces/IDataReceiver.sol';\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\nimport {Create2Address} from '../libraries/Create2Address.sol';\n\ncontract DataReceiverForTest is DataReceiver {\n  constructor(address _governor, IOracleFactory _oracleFactory) DataReceiver(_governor, _oracleFactory) {}\n\n  function internalAddObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external {\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\n  }\n}\n"
    },
    "solidity/contracts/DataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {OracleSidechain} from './OracleSidechain.sol';\nimport {Governable} from './peripherals/Governable.sol';\nimport {IDataReceiver, IOracleSidechain, IBridgeReceiverAdapter} from '../interfaces/IDataReceiver.sol';\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\nimport {Create2Address} from '../libraries/Create2Address.sol';\n\ncontract DataReceiver is IDataReceiver, Governable {\n  /// @inheritdoc IDataReceiver\n  IOracleFactory public oracleFactory;\n\n  bytes32 public constant ORACLE_INIT_CODE_HASH = 0xd3c84c76027a893c261cc6c48447a62206e59286b7bfc08c0e71e1c581d1b012;\n\n  /// @inheritdoc IDataReceiver\n  mapping(IBridgeReceiverAdapter => bool) public whitelistedAdapters;\n\n  constructor(address _governor, IOracleFactory _oracleFactory) Governable(_governor) {\n    oracleFactory = _oracleFactory;\n  }\n\n  function _writeObservations(\n    IOracleSidechain _oracle,\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    uint24 _poolNonce\n  ) internal {\n    if (_oracle.write(_observationsData, _poolNonce)) {\n      emit ObservationsAdded(msg.sender, _observationsData);\n    } else {\n      revert ObservationsNotWritable();\n    }\n  }\n\n  function addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external onlyWhitelistedAdapters {\n    _addObservations(_observationsData, _poolSalt, _poolNonce);\n  }\n\n  function _addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) internal {\n    IOracleSidechain _resultingAddress = IOracleSidechain(\n      Create2Address.computeAddress(address(oracleFactory), _poolSalt, ORACLE_INIT_CODE_HASH)\n    );\n    bool _isDeployed = address(_resultingAddress).code.length > 0;\n    if (_isDeployed) {\n      return _writeObservations(_resultingAddress, _observationsData, _poolNonce);\n    }\n    address _deployedOracle = oracleFactory.deployOracle(_poolSalt, _poolNonce);\n    _writeObservations(IOracleSidechain(_deployedOracle), _observationsData, _poolNonce);\n  }\n\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external onlyGovernor {\n    _whitelistAdapter(_receiverAdapter, _isWhitelisted);\n  }\n\n  /// @inheritdoc IDataReceiver\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external onlyGovernor {\n    uint256 _receiverAdapterLength = _receiverAdapters.length;\n    if (_receiverAdapterLength != _isWhitelisted.length) revert LengthMismatch();\n    unchecked {\n      for (uint256 _i; _i < _receiverAdapterLength; ++_i) {\n        _whitelistAdapter(_receiverAdapters[_i], _isWhitelisted[_i]);\n      }\n    }\n  }\n\n  function _whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) internal {\n    whitelistedAdapters[_receiverAdapter] = _isWhitelisted;\n    emit AdapterWhitelisted(_receiverAdapter, _isWhitelisted);\n  }\n\n  modifier onlyWhitelistedAdapters() {\n    if (!whitelistedAdapters[IBridgeReceiverAdapter(msg.sender)]) revert UnallowedAdapter();\n    _;\n  }\n}\n"
    },
    "solidity/contracts/OracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {Oracle} from '@uniswap/v3-core/contracts/libraries/Oracle.sol';\nimport {IOracleSidechain} from '../interfaces/IOracleSidechain.sol';\nimport {IOracleFactory} from '../interfaces/IOracleFactory.sol';\n\n/// @title A sidechain oracle contract\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Computes on-chain price data from Mainnet\n/// @dev Bridges Uniswap V3 pool observations\ncontract OracleSidechain is IOracleSidechain {\n  using Oracle for Oracle.Observation[65535];\n\n  /// @inheritdoc IOracleSidechain\n  IOracleFactory public immutable factory;\n\n  struct Slot0 {\n    // the current price\n    uint160 sqrtPriceX96;\n    // the current tick\n    int24 tick;\n    // the most-recently updated index of the observations array\n    uint16 observationIndex;\n    // the current maximum number of observations that are being stored\n    uint16 observationCardinality;\n    // the next maximum number of observations to store, triggered in observations.write\n    uint16 observationCardinalityNext;\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\n    // represented as an integer denominator (1/x)%\n    uint8 feeProtocol;\n    // whether the pool is locked\n    bool unlocked;\n  }\n  /// @inheritdoc IOracleSidechain\n  Slot0 public slot0;\n\n  /// @inheritdoc IOracleSidechain\n  Oracle.Observation[65535] public observations;\n\n  /// @inheritdoc IOracleSidechain\n  bytes32 public immutable poolSalt;\n\n  uint24 public poolNonce;\n  /// @inheritdoc IOracleSidechain\n  address public token0;\n  /// @inheritdoc IOracleSidechain\n  address public token1;\n  /// @inheritdoc IOracleSidechain\n  uint24 public fee;\n\n  /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\n  function _getBlockTimestamp() internal view virtual returns (uint32) {\n    return uint32(block.timestamp); // truncation is desired\n  }\n\n  constructor() {\n    uint16 _cardinality;\n    // TODO: remove factory from parameters (use msg.sender)\n    (factory, poolSalt, poolNonce, _cardinality) = IOracleFactory(msg.sender).oracleParameters();\n\n    slot0 = Slot0({\n      sqrtPriceX96: 0,\n      tick: 0,\n      observationIndex: _cardinality - 1,\n      observationCardinality: _cardinality,\n      observationCardinalityNext: _cardinality,\n      feeProtocol: 0,\n      unlocked: true\n    });\n  }\n\n  /*\n   * NOTE: public function that allows signer to register token0, token1 and fee\n   *       before someone registers, oracle can be found with poolSalt, but token0 and token1 views will return address(0)\n   */\n  /// @inheritdoc IOracleSidechain\n  function initializePoolInfo(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external {\n    if (!slot0.unlocked) revert AI();\n\n    (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\n    if (poolSalt != keccak256(abi.encode(_token0, _token1, _fee))) revert InvalidPool();\n\n    token0 = _token0;\n    token1 = _token1;\n    fee = _fee;\n    slot0.unlocked = false;\n\n    emit PoolInfoInitialized(poolSalt, _token0, _token1, _fee);\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function observe(uint32[] calldata _secondsAgos)\n    external\n    view\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s)\n  {\n    return observations.observe(_getBlockTimestamp(), _secondsAgos, slot0.tick, slot0.observationIndex, 0, slot0.observationCardinality);\n  }\n\n  /// @inheritdoc IOracleSidechain\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external onlyDataReceiver returns (bool _written) {\n    if (_poolNonce != poolNonce++) return false;\n\n    uint256 _observationsDataLength = _observationsData.length;\n    for (uint256 _i; _i < _observationsDataLength; ++_i) {\n      _write(_observationsData[_i]);\n    }\n    return true;\n  }\n\n  function _write(ObservationData memory _observationData) private {\n    (uint16 _indexUpdated, uint16 _cardinalityUpdated) = observations.write(\n      slot0.observationIndex,\n      _observationData.blockTimestamp,\n      slot0.tick,\n      0,\n      slot0.observationCardinality,\n      slot0.observationCardinalityNext\n    );\n    (slot0.observationIndex, slot0.observationCardinality) = (_indexUpdated, _cardinalityUpdated);\n    slot0.tick = _observationData.tick;\n    emit ObservationWritten(msg.sender, _observationData);\n  }\n\n  modifier onlyDataReceiver() {\n    if (msg.sender != address(factory.dataReceiver())) revert OnlyDataReceiver();\n    _;\n  }\n}\n"
    },
    "solidity/interfaces/IDataReceiver.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleFactory} from './IOracleFactory.sol';\nimport {IOracleSidechain} from './IOracleSidechain.sol';\nimport {IBridgeReceiverAdapter} from './bridges/IBridgeReceiverAdapter.sol';\nimport {IGovernable} from './peripherals/IGovernable.sol';\n\n/// @title The DataReceiver interface\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Contains state variables, events, custom errors and functions used in DataReceiver\ninterface IDataReceiver is IGovernable {\n  // STATE VARIABLES\n\n  function oracleFactory() external view returns (IOracleFactory _oracleFactory);\n\n  //solhint-disable-next-line func-name-mixedcase\n  function ORACLE_INIT_CODE_HASH() external view returns (bytes32 _oracleInitCodeHash);\n\n  function whitelistedAdapters(IBridgeReceiverAdapter _adapter) external view returns (bool _isAllowed);\n\n  // EVENTS\n\n  event ObservationsAdded(address _user, IOracleSidechain.ObservationData[] _observationsData);\n\n  event AdapterWhitelisted(IBridgeReceiverAdapter _adapter, bool _isAllowed);\n\n  // ERRORS\n\n  error ObservationsNotWritable();\n\n  error UnallowedAdapter();\n\n  error LengthMismatch();\n\n  // FUNCTIONS\n\n  function addObservations(\n    IOracleSidechain.ObservationData[] memory _observationsData,\n    bytes32 _poolSalt,\n    uint24 _poolNonce\n  ) external;\n\n  function whitelistAdapter(IBridgeReceiverAdapter _receiverAdapter, bool _isWhitelisted) external;\n\n  function whitelistAdapters(IBridgeReceiverAdapter[] calldata _receiverAdapters, bool[] calldata _isWhitelisted) external;\n}\n"
    },
    "solidity/interfaces/IOracleFactory.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleSidechain} from './IOracleSidechain.sol';\nimport {IDataReceiver} from './IDataReceiver.sol';\nimport {IGovernable} from './peripherals/IGovernable.sol';\n\ninterface IOracleFactory is IGovernable {\n  // STRUCTS\n\n  struct OracleParameters {\n    IOracleFactory factory;\n    bytes32 poolSalt;\n    uint24 poolNonce;\n    uint16 cardinality;\n  }\n\n  // STATE VARIABLES\n\n  function dataReceiver() external view returns (IDataReceiver _dataReceiver);\n\n  /// @return _factory The address of the deployer factory\n  /// @return _poolSalt The id of both the oracle and the pool\n  /// @return _poolNonce The initial nonce of the pool data\n  /// @return _cardinality The size of the observations memory storage\n  function oracleParameters()\n    external\n    view\n    returns (\n      IOracleFactory _factory,\n      bytes32 _poolSalt,\n      uint24 _poolNonce,\n      uint16 _cardinality\n    );\n\n  /// @return _initialCardinality The initial size of the observations memory storage for newly deployed pools\n  function initialCardinality() external view returns (uint16 _initialCardinality);\n\n  // EVENTS\n\n  event OracleDeployed(address _oracle, bytes32 _poolSalt, uint16 _cardinality);\n  event DataReceiverSet(IDataReceiver _dataReceiver);\n\n  event InitialCardinalitySet(uint16 _initialCardinality);\n\n  // ERRORS\n\n  error OnlyDataReceiver();\n\n  // VIEWS\n\n  /// @notice Overrides UniV3Factory getPool mapping\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  /// @return _oracle The oracle address\n  function getPool(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external view returns (address _oracle);\n\n  /// @param _tokenA The contract address of either token0 or token1\n  /// @param _tokenB The contract address of the other token\n  /// @param _fee The fee denominated in hundredths of a bip\n  /// @return _poolSalt Pool salt for inquired parameters\n  function getPoolSalt(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external view returns (bytes32 _poolSalt);\n\n  // FUNCTIONS\n\n  /// @notice Deploys a new oracle given an inputted salt\n  /// @dev Requires that the salt has not been deployed before\n  /// @param _poolSalt Pool salt that deterministically binds an oracle with a pool\n  /// @return _deployedOracle The address of the newly deployed oracle\n  function deployOracle(bytes32 _poolSalt, uint24 _poolNonce) external returns (address _deployedOracle);\n\n  /// @notice Allows governor to set a new allowed dataReceiver\n  /// @dev Will disallow the previous dataReceiver\n  /// @param _dataReceiver The address of the new allowed dataReceiver\n  function setDataReceiver(IDataReceiver _dataReceiver) external;\n\n  /// @notice Allows governor to set a new initial cardinality for new oracles\n  /// @param _initialCardinality The initial size of the observations memory storage for newly deployed pools\n  function setInitialCardinality(uint16 _initialCardinality) external;\n}\n"
    },
    "solidity/libraries/Create2Address.sol": {
      "content": "//SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.8 <0.9.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary Create2Address {\n  /// @notice Deterministically computes the pool address given the factory, salt and initCodeHash\n  /// @param _factory The Uniswap V3 factory contract address\n  /// @param _salt The PoolKey encoded bytes\n  /// @param _initCodeHash The Init Code Hash of the target\n  /// @return _pool The contract address of the target pool/oracle\n  function computeAddress(\n    address _factory,\n    bytes32 _salt,\n    bytes32 _initCodeHash\n  ) internal pure returns (address _pool) {\n    _pool = address(uint160(uint256(keccak256(abi.encodePacked(hex'ff', _factory, _salt, _initCodeHash)))));\n  }\n}\n"
    },
    "solidity/contracts/peripherals/Governable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IGovernable} from '../../interfaces/peripherals/IGovernable.sol';\n\nabstract contract Governable is IGovernable {\n  /// @inheritdoc IGovernable\n  address public governor;\n  /// @inheritdoc IGovernable\n  address public pendingGovernor;\n\n  constructor(address _governor) {\n    if (_governor == address(0)) revert ZeroAddress();\n    governor = _governor;\n  }\n\n  /// @inheritdoc IGovernable\n  function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\n    _setPendingGovernor(_pendingGovernor);\n  }\n\n  /// @inheritdoc IGovernable\n  function acceptPendingGovernor() external onlyPendingGovernor {\n    _acceptPendingGovernor();\n  }\n\n  function _setPendingGovernor(address _pendingGovernor) internal {\n    if (_pendingGovernor == address(0)) revert ZeroAddress();\n    pendingGovernor = _pendingGovernor;\n    emit PendingGovernorSet(governor, pendingGovernor);\n  }\n\n  function _acceptPendingGovernor() internal {\n    governor = pendingGovernor;\n    pendingGovernor = address(0);\n    emit PendingGovernorAccepted(governor);\n  }\n\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert OnlyGovernor();\n    _;\n  }\n\n  modifier onlyPendingGovernor() {\n    if (msg.sender != pendingGovernor) revert OnlyPendingGovernor();\n    _;\n  }\n}\n"
    },
    "solidity/interfaces/IOracleSidechain.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleFactory} from './IOracleFactory.sol';\n\n/// @title The OracleSidechain interface\n/// @author 0xJabberwock (from DeFi Wonderland)\n/// @notice Contains state variables, events, custom errors and functions used in OracleSidechain\ninterface IOracleSidechain {\n  // STRUCTS\n\n  struct ObservationData {\n    uint32 blockTimestamp;\n    int24 tick;\n  }\n\n  // STATE VARIABLES\n\n  // TODO: complete natspec\n\n  function factory() external view returns (IOracleFactory _oracleFactory);\n\n  function token0() external view returns (address _token0);\n\n  function token1() external view returns (address _token1);\n\n  function fee() external view returns (uint24 _fee);\n\n  function poolSalt() external view returns (bytes32 _poolSalt);\n\n  function poolNonce() external view returns (uint24 _poolNonce);\n\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return _sqrtPriceX96 Used to maintain compatibility with Uniswap V3\n  /// @return _tick Used to maintain compatibility with Uniswap V3\n  /// @return _observationIndex The index of the last oracle observation that was written,\n  /// @return _observationCardinality The current maximum number of observations stored in the pool,\n  /// @return _observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// @return _feeProtocol Used to maintain compatibility with Uniswap V3\n  /// @return _unlocked Used to maintain compatibility with Uniswap V3\n  function slot0()\n    external\n    view\n    returns (\n      uint160 _sqrtPriceX96,\n      int24 _tick,\n      uint16 _observationIndex,\n      uint16 _observationCardinality,\n      uint16 _observationCardinalityNext,\n      uint8 _feeProtocol,\n      bool _unlocked\n    );\n\n  /// @notice Returns data about a specific observation index\n  /// @param _index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return _blockTimestamp The timestamp of the observation,\n  /// @return _tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// @return _secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// @return _initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 _index)\n    external\n    view\n    returns (\n      uint32 _blockTimestamp,\n      int56 _tickCumulative,\n      uint160 _secondsPerLiquidityCumulativeX128,\n      bool _initialized\n    );\n\n  // EVENTS\n\n  event PoolInfoInitialized(bytes32 _poolSalt, address _token0, address _token1, uint24 _fee);\n  event ObservationWritten(address _user, ObservationData _observationData);\n\n  // ERRORS\n\n  error AI();\n  error InvalidPool();\n  error OnlyDataReceiver();\n\n  // FUNCTIONS\n\n  function initializePoolInfo(\n    address _tokenA,\n    address _tokenB,\n    uint24 _fee\n  ) external;\n\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param _secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return _tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return _secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata _secondsAgos)\n    external\n    view\n    returns (int56[] memory _tickCumulatives, uint160[] memory _secondsPerLiquidityCumulativeX128s);\n\n  function write(ObservationData[] memory _observationsData, uint24 _poolNonce) external returns (bool _written);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/Oracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n    error I();\n    error OLD();\n\n    struct Observation {\n        // the block timestamp of the observation\n        uint32 blockTimestamp;\n        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n        int56 tickCumulative;\n        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n        uint160 secondsPerLiquidityCumulativeX128;\n        // whether or not the observation is initialized\n        bool initialized;\n    }\n\n    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n    /// @param last The specified observation to be transformed\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @return Observation The newly populated observation\n    function transform(\n        Observation memory last,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity\n    ) private pure returns (Observation memory) {\n        unchecked {\n            uint32 delta = blockTimestamp - last.blockTimestamp;\n            return\n                Observation({\n                    blockTimestamp: blockTimestamp,\n                    tickCumulative: last.tickCumulative + int56(tick) * int56(uint56(delta)),\n                    secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +\n                        ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n                    initialized: true\n                });\n        }\n    }\n\n    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n    /// @param self The stored oracle array\n    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n    /// @return cardinality The number of populated elements in the oracle array\n    /// @return cardinalityNext The new length of the oracle array, independent of population\n    function initialize(Observation[65535] storage self, uint32 time)\n        internal\n        returns (uint16 cardinality, uint16 cardinalityNext)\n    {\n        self[0] = Observation({\n            blockTimestamp: time,\n            tickCumulative: 0,\n            secondsPerLiquidityCumulativeX128: 0,\n            initialized: true\n        });\n        return (1, 1);\n    }\n\n    /// @notice Writes an oracle observation to the array\n    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n    /// @param self The stored oracle array\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param blockTimestamp The timestamp of the new observation\n    /// @param tick The active tick at the time of the new observation\n    /// @param liquidity The total in-range liquidity at the time of the new observation\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @param cardinalityNext The new length of the oracle array, independent of population\n    /// @return indexUpdated The new index of the most recently written element in the oracle array\n    /// @return cardinalityUpdated The new cardinality of the oracle array\n    function write(\n        Observation[65535] storage self,\n        uint16 index,\n        uint32 blockTimestamp,\n        int24 tick,\n        uint128 liquidity,\n        uint16 cardinality,\n        uint16 cardinalityNext\n    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n        unchecked {\n            Observation memory last = self[index];\n\n            // early return if we've already written an observation this block\n            if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n            // if the conditions are right, we can bump the cardinality\n            if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n                cardinalityUpdated = cardinalityNext;\n            } else {\n                cardinalityUpdated = cardinality;\n            }\n\n            indexUpdated = (index + 1) % cardinalityUpdated;\n            self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n        }\n    }\n\n    /// @notice Prepares the oracle array to store up to `next` observations\n    /// @param self The stored oracle array\n    /// @param current The current next cardinality of the oracle array\n    /// @param next The proposed next cardinality which will be populated in the oracle array\n    /// @return next The next cardinality which will be populated in the oracle array\n    function grow(\n        Observation[65535] storage self,\n        uint16 current,\n        uint16 next\n    ) internal returns (uint16) {\n        unchecked {\n            if (current <= 0) revert I();\n            // no-op if the passed next value isn't greater than the current next value\n            if (next <= current) return current;\n            // store in each slot to prevent fresh SSTOREs in swaps\n            // this data will not be used because the initialized boolean is still false\n            for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\n            return next;\n        }\n    }\n\n    /// @notice comparator for 32-bit timestamps\n    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n    /// @param time A timestamp truncated to 32 bits\n    /// @param a A comparison timestamp from which to determine the relative position of `time`\n    /// @param b From which to determine the relative position of `time`\n    /// @return Whether `a` is chronologically <= `b`\n    function lte(\n        uint32 time,\n        uint32 a,\n        uint32 b\n    ) private pure returns (bool) {\n        unchecked {\n            // if there hasn't been overflow, no need to adjust\n            if (a <= time && b <= time) return a <= b;\n\n            uint256 aAdjusted = a > time ? a : a + 2**32;\n            uint256 bAdjusted = b > time ? b : b + 2**32;\n\n            return aAdjusted <= bAdjusted;\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n    /// The result may be the same observation, or adjacent observations.\n    /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation recorded before, or at, the target\n    /// @return atOrAfter The observation recorded at, or after, the target\n    function binarySearch(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        uint16 index,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            uint256 l = (index + 1) % cardinality; // oldest observation\n            uint256 r = l + cardinality - 1; // newest observation\n            uint256 i;\n            while (true) {\n                i = (l + r) / 2;\n\n                beforeOrAt = self[i % cardinality];\n\n                // we've landed on an uninitialized tick, keep searching higher (more recently)\n                if (!beforeOrAt.initialized) {\n                    l = i + 1;\n                    continue;\n                }\n\n                atOrAfter = self[(i + 1) % cardinality];\n\n                bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n                // check if we've found the answer!\n                if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n                if (!targetAtOrAfter) r = i - 1;\n                else l = i + 1;\n            }\n        }\n    }\n\n    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n    /// @dev Assumes there is at least 1 initialized observation.\n    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param target The timestamp at which the reserved observation should be for\n    /// @param tick The active tick at the time of the returned or simulated observation\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The total pool liquidity at the time of the call\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n    /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n    function getSurroundingObservations(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 target,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n        unchecked {\n            // optimistically set before to the newest observation\n            beforeOrAt = self[index];\n\n            // if the target is chronologically at or after the newest observation, we can early return\n            if (lte(time, beforeOrAt.blockTimestamp, target)) {\n                if (beforeOrAt.blockTimestamp == target) {\n                    // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n                    return (beforeOrAt, atOrAfter);\n                } else {\n                    // otherwise, we need to transform\n                    return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n                }\n            }\n\n            // now, set before to the oldest observation\n            beforeOrAt = self[(index + 1) % cardinality];\n            if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n            // ensure that the target is chronologically at or after the oldest observation\n            if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\n\n            // if we've reached this point, we have to binary search\n            return binarySearch(self, time, target, index, cardinality);\n        }\n    }\n\n    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n    /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n    /// at exactly the timestamp between the two observations.\n    /// @param self The stored oracle array\n    /// @param time The current block timestamp\n    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n    function observeSingle(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32 secondsAgo,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n        unchecked {\n            if (secondsAgo == 0) {\n                Observation memory last = self[index];\n                if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n                return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n            }\n\n            uint32 target = time - secondsAgo;\n\n            (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\n                self,\n                time,\n                target,\n                tick,\n                index,\n                liquidity,\n                cardinality\n            );\n\n            if (target == beforeOrAt.blockTimestamp) {\n                // we're at the left boundary\n                return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n            } else if (target == atOrAfter.blockTimestamp) {\n                // we're at the right boundary\n                return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n            } else {\n                // we're in the middle\n                uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n                uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n                return (\n                    beforeOrAt.tickCumulative +\n                        ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\n                        int56(uint56(targetDelta)),\n                    beforeOrAt.secondsPerLiquidityCumulativeX128 +\n                        uint160(\n                            (uint256(\n                                atOrAfter.secondsPerLiquidityCumulativeX128 -\n                                    beforeOrAt.secondsPerLiquidityCumulativeX128\n                            ) * targetDelta) / observationTimeDelta\n                        )\n                );\n            }\n        }\n    }\n\n    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n    /// @dev Reverts if `secondsAgos` > oldest observation\n    /// @param self The stored oracle array\n    /// @param time The current block.timestamp\n    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n    /// @param tick The current tick\n    /// @param index The index of the observation that was most recently written to the observations array\n    /// @param liquidity The current in-range pool liquidity\n    /// @param cardinality The number of populated elements in the oracle array\n    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n    function observe(\n        Observation[65535] storage self,\n        uint32 time,\n        uint32[] memory secondsAgos,\n        int24 tick,\n        uint16 index,\n        uint128 liquidity,\n        uint16 cardinality\n    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n        unchecked {\n            if (cardinality <= 0) revert I();\n\n            tickCumulatives = new int56[](secondsAgos.length);\n            secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n            for (uint256 i = 0; i < secondsAgos.length; i++) {\n                (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\n                    self,\n                    time,\n                    secondsAgos[i],\n                    tick,\n                    index,\n                    liquidity,\n                    cardinality\n                );\n            }\n        }\n    }\n}\n"
    },
    "solidity/interfaces/peripherals/IGovernable.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity >=0.8.8 <0.9.0;\n\ninterface IGovernable {\n  // STATE VARIABLES\n\n  /// @return _governor Address of the current governor\n  function governor() external view returns (address _governor);\n\n  /// @return _pendingGovernor Address of the current pending governor\n  function pendingGovernor() external view returns (address _pendingGovernor);\n\n  // EVENTS\n\n  /// @notice Emitted when a new pending governor is set\n  /// @param _governor Address of the current governor\n  /// @param _pendingGovernor Address of the proposed next governor\n  event PendingGovernorSet(address _governor, address _pendingGovernor);\n\n  /// @notice Emitted when a new governor is set\n  /// @param _newGovernor Address of the new governor\n  event PendingGovernorAccepted(address _newGovernor);\n\n  // ERRORS\n\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if a non-governor user tries to call a OnlyGovernor function\n  error OnlyGovernor();\n\n  /// @notice Throws if a non-pending-governor user tries to call a OnlyPendingGovernor function\n  error OnlyPendingGovernor();\n\n  // FUNCTIONS\n\n  /// @notice Allows a governor to propose a new governor\n  /// @param _pendingGovernor Address of the proposed new governor\n  function setPendingGovernor(address _pendingGovernor) external;\n\n  /// @notice Allows a proposed governor to accept the governance\n  function acceptPendingGovernor() external;\n}\n"
    },
    "solidity/interfaces/bridges/IBridgeReceiverAdapter.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.8 <0.9.0;\n\nimport {IOracleSidechain} from '../IOracleSidechain.sol';\n\ninterface IBridgeReceiverAdapter {\n  // FUNCTIONS\n\n  /* NOTE: callback methods should be here declared */\n\n  // EVENTS\n\n  event DataSent(IOracleSidechain.ObservationData[] _observationsData, bytes32 _poolSalt);\n\n  // ERRORS\n\n  error UnauthorizedCaller();\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}